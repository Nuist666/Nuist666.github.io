<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java笔记 | Nuist666的个人博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="JavaJava基础&#x2F;&#x2F;单行注释&#x2F;*多行注释 注意 注释不会被编译但是 注释中不可以出现*&#x2F;变量的命名规则java中的变量命名只可以使用数字 字母 _ $不可以使用数字开头中文变量名可以通过编译 但是不建议使用如果在编译的时候出现了GBK不可以映射字符的问题需要将当前文件的编码修改为ANSI（GBL编码）见名知义 驼峰命名法在java中 变量名 方法名使用小">
<meta property="og:type" content="article">
<meta property="og:title" content="Java笔记">
<meta property="og:url" content="https://nuist666.github.io/2024/12/07/Java%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Nuist666的个人博客">
<meta property="og:description" content="JavaJava基础&#x2F;&#x2F;单行注释&#x2F;*多行注释 注意 注释不会被编译但是 注释中不可以出现*&#x2F;变量的命名规则java中的变量命名只可以使用数字 字母 _ $不可以使用数字开头中文变量名可以通过编译 但是不建议使用如果在编译的时候出现了GBK不可以映射字符的问题需要将当前文件的编码修改为ANSI（GBL编码）见名知义 驼峰命名法在java中 变量名 方法名使用小">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-12-07T07:57:27.131Z">
<meta property="article:modified_time" content="2024-12-07T07:59:45.257Z">
<meta property="article:author" content="Nuist666">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Nuist666的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 7.1.1"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">Nuist666</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Nuist666" title="github">github</a>
					        
								<a class="mail" target="_blank" href="mailto:202183290043@nuist.edu.cn" title="mail">mail</a>
					        
								<a class="weibo" target="_blank" href="https://weibo.com/u/5586096129" title="weibo">weibo</a>
					        
								<a class="twitter" target="_blank" href="https://twitter.com/nuist_666" title="twitter">twitter</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=28411862&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Overflow-Mirai-LLOneBot-OneBot/" style="font-size: 10px;">Overflow,Mirai,LLOneBot,OneBot</a> <a href="/tags/python-%E6%B0%94%E8%B1%A1%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B/" style="font-size: 20px;">python,气象信息系统工程</a> <a href="/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-Hexo/" style="font-size: 10px;">华为云,个人博客,Hexo</a> <a href="/tags/%E6%A8%A1%E6%9D%BF-%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E4%B8%89%E5%B3%B0%E7%9C%9F%E7%99%BD-%E6%96%B0%E5%BB%BA/" style="font-size: 10px;">模板,小书匠,三峰真白,新建</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://qm.qq.com/q/HrJvHGMzek">qq</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://space.bilibili.com/3546647772531174">bilibili</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">I&#39;m a student in NUIST.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

<img src="1" onerror="localStorage.setItem('modelId','25')" style="display: none;">

<script>

// live2d_path 参数建议使用绝对路径
const live2d_path = "https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/";
//const live2d_path = "/live2d-widget/";

// 封装异步加载资源的方法
function loadExternalResource(url, type) {
	return new Promise((resolve, reject) => {
		let tag;

		if (type === "css") {
			tag = document.createElement("link");
			tag.rel = "stylesheet";
			tag.href = url;
		}
		else if (type === "js") {
			tag = document.createElement("script");
			tag.src = url;
		}
		if (tag) {
			tag.onload = () => resolve(url);
			tag.onerror = () => reject(url);
			document.head.appendChild(tag);
		}
	});
}

// 加载 waifu.css live2d.min.js waifu-tips.js
	Promise.all([
		loadExternalResource(live2d_path + "waifu.css", "css"),
		loadExternalResource(live2d_path + "live2d.min.js", "js"),
		loadExternalResource(live2d_path + "waifu-tips.js", "js")
	]).then(() => {
		// 配置选项的具体用法见 README.md
		initWidget({
			waifuPath: live2d_path + "waifu-tips.json",
			apiPath: "https://api.zsq.im/live2d/",
			//cdnPath: "https://fastly.jsdelivr.net/gh/fghrsh/live2d_api/",
			tools: ["hitokoto", "asteroids", "switch-model", "switch-texture", "photo", "info", "quit"]
		});
	});

console.log(`
  く__,.ヘヽ.        /  ,ー､ 〉
           ＼ ', !-─‐-i  /  /´
           ／｀ｰ'       L/／｀ヽ､
         /   ／,   /|   ,   ,       ',
       ｲ   / /-‐/  ｉ  L_ ﾊ ヽ!   i
        ﾚ ﾍ 7ｲ｀ﾄ   ﾚ'ｧ-ﾄ､!ハ|   |
          !,/7 '0'     ´0iソ|    |
          |.从"    _     ,,,, / |./    |
          ﾚ'| i＞.､,,__  _,.イ /   .i   |
            ﾚ'| | / k_７_/ﾚ'ヽ,  ﾊ.  |
              | |/i 〈|/   i  ,.ﾍ |  i  |
             .|/ /  ｉ：    ﾍ!    ＼  |
              kヽ>､ﾊ    _,.ﾍ､    /､!
              !'〈//｀Ｔ´', ＼ ｀'7'ｰr'
              ﾚ'ヽL__|___i,___,ンﾚ|ノ
                  ﾄ-,/  |___./
                  'ｰ'    !_,.:
`);

</script>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/avatar.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Nuist666" title="github">github</a>
			        
						<a class="mail" target="_blank" href="mailto:202183290043@nuist.edu.cn" title="mail">mail</a>
			        
						<a class="weibo" target="_blank" href="https://weibo.com/u/5586096129" title="weibo">weibo</a>
			        
						<a class="twitter" target="_blank" href="https://twitter.com/nuist_666" title="twitter">twitter</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-Java笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/12/07/Java%E7%AC%94%E8%AE%B0/" class="article-date">
  	<time datetime="2024-12-07T07:57:27.131Z" itemprop="datePublished">2024-12-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java笔记
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-12/">/小书匠/日记/2024-12</a>
	</div>


        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><p>&#x2F;&#x2F;单行注释<br>&#x2F;*<br>多行注释 注意 注释不会被编译<br>但是 注释中不可以出现<br>*&#x2F;<br>变量的命名规则<br>java中的变量命名只可以使用数字 字母 _ $<br>不可以使用数字开头<br>中文变量名可以通过编译 但是不建议使用<br>如果在编译的时候出现了GBK不可以映射字符的问题<br>需要将当前文件的编码修改为ANSI（GBL编码）<br>见名知义 驼峰命名法<br>在java中 变量名 方法名使用小驼峰<br>类名 使用大驼峰<br>类名首字母必须大写 java中自带的关键字不可以作为类名</p>
<pre><code>int studentage=28;
String studentName=&quot;kun&quot;;
</code></pre>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>4整型 2浮点型 一种布尔型 1种字符型</p>
<p>byte short int long<br>byte  8位  -128~127<br>short 16位 -2^15 ~ 2^15-1<br>int   32位 -2^31 ~2<del>^31-1<br>long  63位 -2^</del>63 ~ 2^63-1</p>
<p>int a &#x3D; 0x11;</p>
<h4 id="数据类型的范围"><a href="#数据类型的范围" class="headerlink" title="数据类型的范围"></a>数据类型的范围</h4><pre><code>    System.out.println(Short.MIN_VALUE);
    System.out.println(Short.MAX_VALUE);
    System.out.println(Integer.MIN_VALUE);
    System.out.println(Integer.MAX_VALUE);
    System.out.println(Long.MIN_VALUE);
    System.out.println(Long.MAX_VALUE);
</code></pre>
<p>java中 整型数据的字面量值 默认为int类型;</p>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>大类型转小类型 强制类型转换<br>小类型转大类型 隐式类型转换<br>byte a &#x3D; (byte)200;<br>System.out.println(a);<br>long l &#x3D; 21474836481L;<br>System.out.println(l);</p>
<h5 id="字符型-只能存储一个字符"><a href="#字符型-只能存储一个字符" class="headerlink" title="字符型 只能存储一个字符"></a>字符型 只能存储一个字符</h5><pre><code>char a = &#39;坤&#39;;
char b = &#39;m&#39;;
char c = 97;
char d = &#39;\u0065&#39;;
System.out.println(a);
System.out.println(b);
System.out.println(c);
System.out.println(d);
byte b =(byte)&#39;a&#39;;
System.out.println(b);	
</code></pre>
<h5 id="浮点型-float-double"><a href="#浮点型-float-double" class="headerlink" title="浮点型 float double"></a>浮点型 float double</h5><h4 id="二进制科学计数法"><a href="#二进制科学计数法" class="headerlink" title="二进制科学计数法"></a>二进制科学计数法</h4><p>float  32位 第一位符号位 指数部分为8位 尾数部分为23位<br>double 64位 第一位符号位 指数部分为11位 尾数部分为52位<br>float 类型数值范围远大于int 但是精度比int小<br>double类型数值范围远大于long 但是精度比long小<br>默认所有小数类型的字面量按照double类型存储<br>float a &#x3D; 1.0f;<br>所有的浮点型计算 本身是实数计算<br>计算机只能存储整数 浮点型的存储实际存储的是约束<br>浮点型的计算会比较慢并且可能出现误差<br>BigDecimal —&gt; decimal</p>
<h5 id="布尔类型-boolean-true-false"><a href="#布尔类型-boolean-true-false" class="headerlink" title="布尔类型 boolean true false"></a>布尔类型 boolean true false</h5><p>4 2 1 1 整浮字布<br>String a &#x3D;”abc”;<br>运算符 + - * &#x2F; % ++ –</p>
<pre><code>    int i=1;
    int a=(i++)-(i--)+(--i)-(++i);//-2

//表达式的值  1    2      0     1
//i的值    	 2   1       0     1
    int b=(++i)-(i++)+(i--)-(--i);//2
//表达式的值  2    2     3      1
//i的值    	2     3     2      1
    System.out.println(i);
    System.out.println(a);
    System.out.println(b);
</code></pre>
<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>&lt; &gt; &lt;&#x3D; &gt;&#x3D; !&#x3D; &#x3D;&#x3D;</p>
<p>与或非 逻辑运算符<br>&amp; |<br>&amp;&amp; || 会出现短路的情况<br>如果运算符左边的表达式结果能决定最终结果 右边的表达式就不会被执行 会被跳过 这种现象叫做短路现象</p>
<pre><code>    int a=1;
    int b=2;
    System.out.println((a++&gt;b++)&amp;&amp;(a++&lt;b++));
    System.out.println(a);
    System.out.println(b);
</code></pre>
<h5 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h5><h5 id="按位与运算"><a href="#按位与运算" class="headerlink" title="&amp; 按位与运算"></a>&amp; 按位与运算</h5><pre><code>    1010
    0100
    0000
    System.out.println(10&amp;4);
    0
</code></pre>
<h5 id="按位或运算"><a href="#按位或运算" class="headerlink" title="| 按位或运算"></a>| 按位或运算</h5><pre><code>    1010
    0100
    1110
    System.out.println(10|4);
    15
</code></pre>
<h5 id="按位异或"><a href="#按位异或" class="headerlink" title="^ 按位异或"></a>^ 按位异或</h5><pre><code>    1010
    0100
    1110
    System.out.println(10|4);
    14
</code></pre>
<h5 id="按位取反"><a href="#按位取反" class="headerlink" title="~ 按位取反"></a>~ 按位取反</h5><pre><code>    +01111
    -10000
    System.out.println(~15);
    -16
    左移 高位溢出 低位补0
    111100
    System.out.println(15&lt;&lt;2);
    70
    右移 小数点不动 所有位右移
    1111.00
    11.11
    System.out.println(15&gt;&gt;2);
    3
</code></pre>
<h4 id="三元表达式-if-else的简写版"><a href="#三元表达式-if-else的简写版" class="headerlink" title="三元表达式 if else的简写版"></a>三元表达式 if else的简写版</h4><pre><code>    int age=18;
    String result=(age&gt;=18)?&quot;老登&quot;:&quot;未成年&quot;;
</code></pre>
<h3 id="顺序结构-分支结构-循环结构"><a href="#顺序结构-分支结构-循环结构" class="headerlink" title="顺序结构 分支结构 循环结构"></a>顺序结构 分支结构 循环结构</h3><pre><code>    String name=&quot;jzy&quot;;
    if(name.equals(&quot;jzy&quot;))&#123;
        System.out.println(&quot;tui!Jerk&quot;);
    &#125;
    System.out.println(&quot;你好，&quot;+name);
    String name=&quot;zsy&quot;;
    if(name.equals(&quot;zsy&quot;))&#123;
    System.out.println(&quot;你是一个好人&quot;);
    &#125;else if(name.equals(&quot;jzy&quot;))&#123;
        System.out.println(&quot;怎么还是你这个Jerk,tui！&quot;);
    &#125;else&#123;
        System.out.println(&quot;what can i say&quot;);
    &#125;
</code></pre>
<h4 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h4><p>switch的key类型不可以是long类型<br>每一个case语句之后都需要有一个break</p>
<pre><code>    String key=&quot;A&quot;;
    switch(key)&#123;
        case &quot;A&quot;:
        System.out.println(&quot;太对了哥&quot;);
        break;
        case&quot;B&quot;:
        System.out.println(&quot;不是哥们&quot;);
        break;
        case&quot;C&quot;:
        System.out.println(&quot;啊对对对&quot;);
        default:
        System.out.println(&quot;？&quot;);
    &#125;
</code></pre>
<h4 id="循环-while循环-do-while循环-for循环"><a href="#循环-while循环-do-while循环-for循环" class="headerlink" title="循环 while循环 do while循环 for循环"></a>循环 while循环 do while循环 for循环</h4><pre><code>1-100和
</code></pre>
<!---->

<pre><code>    int i=1;
    int result=0;
    while(i&lt;=100)&#123;
        result+=i;
        i++;
    &#125;
    System.out.println(result);
</code></pre>
<h5 id="do-while-不管条件是否满足-do后面的语句至少会执行一次"><a href="#do-while-不管条件是否满足-do后面的语句至少会执行一次" class="headerlink" title="do while 不管条件是否满足 do后面的语句至少会执行一次"></a>do while 不管条件是否满足 do后面的语句至少会执行一次</h5><pre><code>    int i=1;
    int result=0;
    do&#123;
        result+=i;
        i++;
    &#125;while(i&lt;=100);
    System.out.println(result);
    
    int result=0;
    for(int i=0;i&lt;=100;i++)&#123;
        result+=i;
    &#125;
    System.out.println(result);
    System.out.println(i);//无效i
</code></pre>
<h5 id="continue-break"><a href="#continue-break" class="headerlink" title="continue break"></a>continue break</h5><p>continue跳出本次循环 继续到下一次循环<br>break  直接结束指定层循环 如果不指定结束哪一层 默认结束当前层<br>求1-100中的所有奇数 如果找到 打印它</p>
<pre><code>    for int(i=1;i&lt;=100;i++)&#123;
        if (i%2==0)&#123;
            continue;
        &#125;
            System.out.println(i);
    &#125;
    //遍历10-99的所有两位数 如果发现个位*十位等于40 则打印找到 并停止查找
    
    for(int i=10;i&lt;=100;i++)&#123;
        int g=i%10;
        int s=i/10;
        if(g*s==40)&#123;
            System.out.println(&quot;找到了，数字是：&quot;+i);
            break;
        &#125;
    &#125;
</code></pre>
<p>遍历1-9的数字 如果两个数字的和等于两个数字的积，则打印这个数字 并且结束循环</p>
<pre><code>    loop:
    for(int i=1;i&lt;10;i++)&#123;
        for(int j=1;j&lt;10;j++)&#123;
            if((i+j)==(i*j))&#123;
                System.out.println(&quot;找到了，数字是：&quot;+i);
                break loop;
            &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="打印内容"><a href="#打印内容" class="headerlink" title="打印内容"></a>打印内容</h3><p>println  允许打印空内容 打印结尾自带换行<br>print()  不允许打印空内容 打印结尾不会自带换行<br>printf() 支持格式化打印<br>占位符 %d 匹配一个整型<br>%s 匹配一个字符串<br>%f 匹配一个浮点型<br>%c 匹配一个字符型<br>%b 匹配一个布尔值类型<br>%n 无需匹配 直接表示换行符</p>
<pre><code>    String name=&quot;jzy&quot;;
    int age=22;
    float height=179.9f;
    char gender=&#39;男&#39;;
    boolean isMarried=false;
    System.out.println(&quot;大家好，我叫&quot;+name+&quot;,今年芳龄为&quot;+age+&quot;,性别为&quot;+gender+&quot;,我的婚姻的布尔值为&quot;+isMarried+&quot;,我的身高为&quot;+height+&quot;cm,希望大家喜欢我&quot;);
    System.out.printf(&quot;大家好，我叫%s，今年芳龄为%d，性别为%c，我的婚姻的布尔值为%b，我的身高为%f，希望大家喜欢我%n&quot;,name,age,gender,isMarried,height);
</code></pre>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>基本java内存分配<br>递归算法 方法的进出栈<br>数组的长度不可改变<br>数组中所存放的数据类型是统一的<br>数组初始化 有两种 静态初始化 动态初始化<br>下面这种写法是数组的动态初始化 只提供数组元素的数量<br>而不提供具体的元素<br>数组元素会有一个默认值 默认值和数组的类型相关<br>byte short int long 0<br>float double 0.0<br>boolean false<br>char \u0000<br>数组的元素通过index进行访问 是基0的</p>
<pre><code>    int[] arr=new int[10]; 
    //arr[3]=1;
    //System.out.println(arr[3]);
    //数组遍历有两种方式 第一种是传统的for循环
    for(int i=0;i&lt;arr.length;i++)&#123;
        System.out.print(arr[i]+&quot;\t&quot;);
    &#125;
    //增强for循环(Iterator迭代器)遍历 语法题
    //增强for循环只能用于遍历 不可以用于元素的赋值和修改
    for(int i:arr)&#123;
        System.out.print(i+&quot;\t&quot;);
    &#125;
</code></pre>
<h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><p>在数组声明的时候就定义好所有的数组元素<br>数组的长度会根据你定义的元素数量自动确定</p>
<pre><code>    int[] arr=new int[]&#123;1,3,5,7&#125;;
    int[] arr=&#123;1,3,5,7&#125;;
    for(int i:arr)&#123;
        System.out.print(i+&quot;\t&quot;);
    &#125;
</code></pre>
<p>java 内存分配青春版</p>
<pre><code>    int[] arr=new int[10];
    arr[1]=1;
    arr[2]=2;
    int[] arr1=arr;//指向的arr地址
    arr1[0]=3;
    arr1[1]=4;
    System.out.print(arr[0]);
    System.out.print(arr[1]);
</code></pre>
<p>现在有如下一个数组：<br>int oldArr[]&#x3D;{1,3,4,5,0,0,6,6,0,5,4,7,6,7,0,5};<br>要求将以上数组中的0项去掉，将不为0的值存入一个新的数组，<br>生成新的数组为:<br>int newArr[]&#x3D;{1,3,4,5,6,6,5,4,7,6,7,5};</p>
<pre><code>    int oldArr[]=&#123;1,3,4,5,0,0,6,6,0,5,4,7,6,7,0,5&#125;;
    int count=0;
    for(int i:oldArr)&#123;
        if(i!=0)&#123;
            count++;
        &#125;
    &#125;
    
    int newArr[]=new int[count];
    int j=0;
    
    for(int i:oldArr)&#123;
        if(i!=0)&#123;
            newArr[j++]=i;
        &#125;
    &#125;
    
    for(int i:newArr)&#123;
        System.out.print(i+&quot;\t&quot;);
    &#125;
</code></pre>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><p>在要排序的一组数中 选出最小的一个和第一个位置的进行交换<br>再在剩下的数中找到最小的和第二个交换 依次类推</p>
<pre><code>    int[] arr=&#123;1,3,2,5,4,7,6,8,9&#125;;
    //定义变量的记录位置
    int position=0;
    for(int i=0;i&lt;arr.length;i++)&#123;
        int j=i+1;
        position=i;
        int temp=arr[i];
        for(;j&lt;arr.length;j++)&#123;
            if(arr[j]&lt;temp)&#123;
                temp=arr[j];
                position=j;
            &#125;
        &#125;
        arr[position]=arr[i];
        arr[i]=temp;
    &#125;
</code></pre>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>在要排序的一组数中 对当前还未排序号的范围内的所有数对相邻数进行比较<br>和交换 让较大的下沉 较小的上冒</p>
<pre><code>    int[] arr=&#123;9,3,2,5,4,7,6,8,1&#125;;
    int temp=0;
    for(int i=0;i&lt;arr.length-1;i++)&#123;
        for(int j=0;j&lt;arr.length-1-i;j++)&#123;
            if(arr[j]&gt;arr[j+1])&#123;
                temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            &#125;
        &#125;
    &#125;
    for(int i:arr)&#123;
        System.out.print(i+&quot;\t&quot;);
    &#125;
</code></pre>
<h4 id="二维数组-矩阵"><a href="#二维数组-矩阵" class="headerlink" title="二维数组 矩阵"></a>二维数组 矩阵</h4><p>静态初始化</p>
<pre><code>    int[][] arr=&#123;
        &#123;1,2,3&#125;,
        &#123;4,5,6,7&#125;,
        &#123;8,9,10,13,15&#125;
    &#125;;
    System.out.print(arr[0][0]);//1
    System.out.print(arr[2][3]);//13
</code></pre>
<h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><pre><code>    int[][] arr=new int[3][];
    arr[0]=new int[]&#123;1,2,3&#125;;
    arr[1]=new int[]&#123;4,5,6,7&#125;;
    arr[2]=new int[]&#123;8,9&#125;;
    for(int i=0;i&lt;arr.length;i++)&#123;
        for(int j=0;j&lt;arr[i].length;j++)&#123;
            System.out.print(arr[i][j]+&quot;\t&quot;);
        &#125;
        System.out.println();
    &#125;
</code></pre>
<h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><h4 id="求1-10的和"><a href="#求1-10的和" class="headerlink" title="求1-10的和"></a>求1-10的和</h4><pre><code>sum(10);
public static int sum(int n)&#123;
        if(n==1)&#123;
            return 1;
        &#125;
        return n+sum(n-1);
    &#125;
</code></pre>
<h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><p>1 1 2 3 5 8 13 21 34 55</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(sum(10));</span><br><span class="line">System.out.println(crazyRabbit(50));</span><br><span class="line">public static int crazyRabbit(int n)&#123;</span><br><span class="line">	if(n==0||n==1)&#123;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return crazyRabbit(n-1)+crazyRabbit(n-2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>方法的修饰符一定包含static<br>方法中有参数 返回值 的概念 方法可以没有参数<br>方法可以没有返回值 但是需要使用void表示没有返回值<br>静态方法通过类进行调用 可以在当前类中调用静态方法 可以省略类名</p>
<pre><code>        HelloWorld.eat();
        eat();
        eatSth(&quot;中苑美食城二楼难吃的瓦香鸡米饭&quot;);
        
        public static void eat()&#123;
        System.out.println(&quot;爱吃中苑老食堂&quot;);
    &#125;
    
    public static void eatSth(String sth)&#123;
        System.out.println(&quot;爱吃&quot;+sth);
        &#125;
</code></pre>
<p>java中不可以出现方法名和参数完全相同的方法</p>
<h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><p>在调用方法的时候 方法名称相同 调用方法的参数不同（数量不同 类型不同 顺序不同）<br>可以实现调用不同的方法 编译时多态<br>方法的返回值 需要声明返回值类型 并且 谁调用方法 谁获取返回值</p>
<h4 id="返回值的参数传递"><a href="#返回值的参数传递" class="headerlink" title="返回值的参数传递"></a>返回值的参数传递</h4><p>引用类型传递的是对象的内存地址<br>基本数据类型传递的是值 String作为引用类型 做的也是值传递</p>
<pre><code>    String result=runLeg(80);
    SYstem.out.println(result);
    learn();
    
    public static void learn()&#123;
        sleep();
        System.out.println(&quot;学习5分钟&quot;);
    &#125;
</code></pre>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="继承特点"><a href="#继承特点" class="headerlink" title="继承特点"></a>继承特点</h4><p>1.子类继承了父类的所有内容<br>2.子类还可以拥有自己特有的内容<br>Person叫做父类 超类 基类<br>其他类叫做子类 派生类<br>共性抽取</p>
<h5 id="继承优点："><a href="#继承优点：" class="headerlink" title="继承优点："></a>继承优点：</h5><p>提高了代码的复用性 提供了开发的效率<br>继承的出现让类和类之间产生了关系 提供了多态的前提</p>
<p>java中只支持单继承 但可以嵌套继承</p>
<pre><code>Class A extends B
Class B extends C
</code></pre>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>如果父类当中的方法不确定如何表达如何进行方法的具体实现，那么这个方法就一个是一个抽象方法<br>具有抽象方法的类 就应该是抽象类</p>
<p>子类在继承抽象类之后 必须重写父类的所有抽象方法 如果不重写 编译无法通过</p>
<h5 id="抽象类的特点"><a href="#抽象类的特点" class="headerlink" title="抽象类的特点"></a>抽象类的特点</h5><p>1.抽象类无法创建对象 只能通过子类创建对象<br>2.子类必须重写父类的所有抽象方法<br>3.抽象类的成员变量 构造函数以及非抽象方法 都是为了给子类进行继承</p>
<h4 id="super的用法"><a href="#super的用法" class="headerlink" title="super的用法"></a>super的用法</h4><p>1.在子类构造函数中调用指定父类构造函数 如果没写 则默认使用super()调用父类的无参构造<br>2.在子类中调用指定的父类方法<br>3.在子类中访问父类的成员变量</p>
<p>如果子类中出现了和父类方法名称以及参数一致的方法，子类中的方法会覆盖父类中的方法，这种现象叫做方法重写</p>
<p>@override出现<br>1.标记的前方法重写了父类方法<br>2.如果当前方法没有重写父类方法 编译不通过</p>
<h4 id="继承的总结"><a href="#继承的总结" class="headerlink" title="继承的总结"></a>继承的总结</h4><p>当一个类继承了另一个类 则子类拥有父类的全部属性和方法<br>如果不想使用父类的方法 则可以通过重写的方式覆盖父类的方法<br>如果父类的属性是private 则子类无法直接访问 可以间接访问</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在jdk7中 接口中只能声明常量<br>jdk8之后 接口中还可以声明静态方法和默认方法<br>jdk9之后 接口中还可以额外包含私有方法</p>
<h4 id="接口的优点"><a href="#接口的优点" class="headerlink" title="接口的优点"></a>接口的优点</h4><p>解决了不能多继承的弊端 实现了多实现</p>
<h4 id="接口和抽象类的区别："><a href="#接口和抽象类的区别：" class="headerlink" title="接口和抽象类的区别："></a>接口和抽象类的区别：</h4><h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h5><p>都可以定义常量和抽象方法<br>都位于继承的顶端<br>都不能直接创建对象</p>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>1.抽象类为部分方法提供实现 避免子类重复实现 提高了代码的复用性 接口只能包含抽象方法（jdk8可以设置静态和默认 jdk9私有）<br>2.抽象类在设计中表示的是某一个业务应该具有的功能 是一种is..a的关系<br>3.接口是一个规范 一个规范描述的是子类应该具有的功能 到那时不提供实现 由子类自己实现 是一种like..a的关系<br>4.抽象类中可以定义成员方法 成员变量 构造方法 接口不可以<br>5.接口中的所有常量必须在命名的时候全部大写 如果出现了多个单词 使用下划线连接</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>一个对象拥有多种形态 叫做对象的多态性</p>
<p>里氏替换原则：任何一个需要父类对象出现的地方都可以使用子类对象进行替换</p>
<p>父类引用指向子类对象</p>
<pre><code>//动态绑定（运行时多态）
Animal a=new Cat();
a.eat();
a=new Dog();
a.eat();
</code></pre>
<!---->

<pre><code> Animal a=new Dog();
 a.eat();
//程序健壮性判断
((Dog)a).fightHouse();
((Cat)a).backFlip();//运行出错
if(a instanceof Cat)&#123;
    Cat c=(Cat)a;
    c.backFlip();
&#125;
</code></pre>
<!---->

<pre><code>//通过多态实现类型的拓展
Animal[] animals = new Dog[10];
animals[0] = new Dog();
animals[1] = new Cat();
</code></pre>
<p>利用多态 对外可以只暴露父类和接口<br>让使用者只能调用接口中定义的方法</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>不可变修饰符</p>
<p>如果修饰类 则表示类不可以被继承<br>如果修饰方法 方法不可以被重写<br>如果修饰基本类型的变量 变量的值不可以更改<br>如果修饰引用类型的变量 引用不可以更改</p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>静态修饰符</p>
<pre><code>String name;
int sno;
static int classNo=525;
</code></pre>
<p>1.静态属性优先于对象存在 不可以在静态方法或代码块中访问this&#x2F;super<br>2.同一个类中 静态属性只能访问静态属性 而不能访问非静态属性</p>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>同类中</p>
<h4 id="default"><a href="#default" class="headerlink" title="(default)"></a>(default)</h4><p>同类中、同包类（子类和非子类）</p>
<h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><p>同类中、同包类（子类和非子类）、不同包子类</p>
<h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><p>同类中、同包类（子类和非子类）、不同包子类、不同包且非子类</p>
<h2 id="系统类"><a href="#系统类" class="headerlink" title="系统类"></a>系统类</h2><h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><p>String、StringBuffer、StringBuilder</p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>不可变字符串 String一旦内容被修改 就一定是创建了新的字符串<br>String底层存储使用的是char数组</p>
<pre><code>abc char[] value&#123;&#39;a&#39;,&#39;b&#39;&#39;c&#39;&#125;
</code></pre>
<p>当传入一个char数组作为构造函数的参数进行初始化的时候，String并没有选择直接使用传入的数组地址进行value属性的赋值，而是复制了一个和传入参数数组元素相同的新数组，避免了传入参数的数组元素改变导致String字符改变的情况出现。</p>
<h5 id="substring和concat"><a href="#substring和concat" class="headerlink" title="substring和concat"></a>substring和concat</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;abcdefg&quot;;</span><br><span class="line">System.out.println(str.substring(2,5));//cde</span><br><span class="line">System.out.println(str.concat(&quot;hij&quot;));//abcdefghij</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="String支持java中的常量池："><a href="#String支持java中的常量池：" class="headerlink" title="String支持java中的常量池："></a>String支持java中的常量池：</h5><p>当String是通过&#x3D;直接赋值，而不是new的时候，字符串会被放到常量池中，常量池中是不会有重复的字符串的</p>
<pre><code>String a =&quot;abc&quot;;
String b =&quot;abc&quot;;
String c = new String(&quot;abc&quot;);
char[] ch=&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;
String d = new String(ch);
String e =&quot;a&quot;+&quot;b&quot;+&quot;c&quot;;
String s1=&quot;a&quot;;
String s2=&quot;b&quot;;
String s3=&quot;c&quot;;
String f=s1+s2+s3;

System.out.println(a.equals(b));//true
System.out.println(a==b);//true
System.out.println(a==c);//false
System.out.println(a==d);//false
System.out.println(a==e);//true
System.out.println(a==f);//false
</code></pre>
<h5 id="连接符"><a href="#连接符" class="headerlink" title="+连接符"></a>+连接符</h5><pre><code>String s1 = &quot;a&quot;;
String s2 = &quot;b&quot;;
String s3 = &quot;c&quot;;
String s4 = s1+s2+s3;
</code></pre>
<p>通过该方法实现而不违反String不可变原则</p>
<pre><code>String s1 = &quot;a&quot;;
String s2 = &quot;b&quot;;
String s3 = &quot;c&quot;;
(new StringBuilder()).append(s1).append(s2).append(s3).toString();
</code></pre>
<h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><p>是线程不安全的，但效率提高了</p>
<p>比较可变字符串值方法需要toString()比较存放地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb1=new StringBuilder(&quot;a&quot;);</span><br><span class="line">StringBuilder sb2=new StringBuilder(&quot;a&quot;);</span><br><span class="line">System.out.println(sb1.toString().equals(sb2.toString()));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p>是现成安全的，牺牲了性能</p>
<h3 id="其他系统常用类"><a href="#其他系统常用类" class="headerlink" title="其他系统常用类"></a>其他系统常用类</h3><p>Scanner、日期相关、数字计算相关、封装类</p>
<h3 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h3><pre><code>import java.util.Scanner;

Scanner sc = new Scanner(System.in);
</code></pre>
<h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><pre><code>Random r=new Random();
int randomNum=r.nextInt(100)+100;//0-99,区间左闭右开
int randomNum=r.nextInt(9)*20;//获取0-180
</code></pre>
<h3 id="封装类"><a href="#封装类" class="headerlink" title="封装类"></a>封装类</h3><p>封装类为基本数据类型而生的类</p>
<pre><code>short-Short 
byte-Byte 
long-Long
double-Double 
boolean-Boolean 
int-Integer
char-Character
</code></pre>
<p>基本数据类型转换为封装类型叫装箱</p>
<pre><code>int i=1;//数据类型
Integer i=1;//封装类型
Integer i=new Integer(1);//引用类型
</code></pre>
<p>封装类型转换为数据类型叫做拆箱</p>
<pre><code>Integer j=1;
int j=1;
</code></pre>
<p>在某些场景中，装箱和拆箱是自动完成的，不需要开发者手动进行类型转换</p>
<pre><code>Integer i=1;
int j=1;
i==j//true
</code></pre>
<p>4种整型的封装类支持使用常量池，但是有范围 -128-127</p>
<pre><code>Integer j=1;
Integer k=1;
j==k//true

Integer l=128;
Integer m=128;
l==m//false
</code></pre>
<p>封装类不能直接用equals()比较，需要转换为相同的数据类型</p>
<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>数学对象</p>
<h3 id="日期相关类"><a href="#日期相关类" class="headerlink" title="日期相关类"></a>日期相关类</h3><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>默认打印系统时间</p>
<pre><code>Date d=new Date();
System.out.println(d);//Wed Nov 13 16:15:20 CST 2024
</code></pre>
<p>可以打印计算机时间原点</p>
<pre><code>Date d=new Date(0);
System.out.println(d);//Thu Jan 01 08:00:00 CST 1970
</code></pre>
<p>打印距离时间原点经过的毫秒数</p>
<pre><code>System.out.println(d.getTime());//1731485842849
</code></pre>
<h4 id="SimpleDateFarmat"><a href="#SimpleDateFarmat" class="headerlink" title="SimpleDateFarmat"></a>SimpleDateFarmat</h4><p>y年 M月 d日 H24小时 h12小时制 m时 s秒 S毫秒</p>
<pre><code>//将一个日期格式的数据类型转换成字符串
        SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        Date d=new Date();
        String s=sdf.format(d);
        Print.print(s);
        //2024-11-13 16:23:08
</code></pre>
<!---->

<pre><code>//将一个字符串转换为日期格式类型
SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
String str=&quot;2022-02-02 22:22:22 222&quot;;
        try &#123;
            Date d=sdf.parse(str);
            System.out.println(&quot;转换的日期对象为：&quot;+d);
        &#125; catch (ParseException e) &#123;
            e.printStackTrace();
        &#125;
</code></pre>
<h4 id="日历类Calender"><a href="#日历类Calender" class="headerlink" title="日历类Calender"></a>日历类Calender</h4><p>可以和日期类型进行转换</p>
<pre><code>//实例化一个日历对象
Calendar c=Calendar.getInstance();
//通过日历对象得到日期对象
Date d=c.getTime();
Date d2=new Date(0);
//将日历的时间设置为d2对应的日期
c.setTime(d2);
</code></pre>
<h5 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h5><p>在当前时间的基础上向未来或者从前调整时间</p>
<pre><code>Calendar c=Calendar.getInstance();
Date now=c.getTime();
System.out.println(now);
//获取下个月的今天
c.add(Calendar.MONTH,1);
System.out.println(c.getTime());
//获取去年的今天
c.setTime(now);
c.add(Calendar.YEAR,-1);
System.out.println(c.getTime());
</code></pre>
<h5 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h5><p>设置指定时间</p>
<pre><code>//获取上个月的第三天
c.setTime(now);
c.add(Calendar.MONTH,-1);
c.set(Calendar.DATE,3);
System.out.println(c.getTime());
</code></pre>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>匿名内部类、静态内部类、非静态内部类、局部内部类、内部接口</p>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><pre><code>USB usb=new USB()&#123;
    public void open() &#123;
        System.out.println(&quot;连接驱动&quot;);
    &#125;
&#125;;
usb.open();
System.out.println(usb.getClass().getName());
System.out.println(usb.getClass()==Class.forName(&quot;test.Test$1&quot;));
</code></pre>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>Throwable、Exception、Error</p>
<h4 id="什么是异常？"><a href="#什么是异常？" class="headerlink" title="什么是异常？"></a>什么是异常？</h4><p>运行时发生的错误叫异常，处理异常的行为叫做异常处理。一旦发生异常，程序会突然终止。</p>
<h4 id="当一个程序出现错误"><a href="#当一个程序出现错误" class="headerlink" title="当一个程序出现错误"></a>当一个程序出现错误</h4><p>1.语法错误 没通过编译<br>2.运行时错误（主要处理的异常类型）<br>3.逻辑错误 bug</p>
<h4 id="java通过面向对象的方式来处理异常"><a href="#java通过面向对象的方式来处理异常" class="headerlink" title="java通过面向对象的方式来处理异常"></a>java通过面向对象的方式来处理异常</h4><p>在方法的运行过程中，如果出现了异常，这个方法就会产生改异常的一个对象，并将对象交给JVM，开发人员通过try{}代码来包含可能出现异常的代码，通过catch{}带捕捉可能出现的异常对象</p>
<pre><code>public void say(int i)&#123;
        int[] arr=&#123;1&#125;;
        try &#123;
            System.out.println(1 / i);
        &#125;catch (ArithmeticException e)&#123;
            System.out.println(&quot;除数不能为0&quot;);
            e.printStackTrace();//输出堆栈的跟踪信息
        &#125;try&#123;
            System.out.println(arr[1]);
        &#125;catch (ArrayIndexOutOfBoundsException e)&#123;
            System.out.println(&quot;数组越界&quot;);
            e.printStackTrace();
        &#125;
        System.out.println(&quot;由于我们做了异常处理，代码发生异常之后，之后的代码也可以正常执行&quot;);
    &#125;
</code></pre>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p>finally代码块的代码都会执行且优先级最高</p>
<pre><code>public void what(int i)&#123;
        try&#123;
            System.out.println(1/i);
        &#125;catch(Exception e)&#123;
            System.out.println(&quot;捕捉到异常&quot;);
            e.printStackTrace();
        &#125;finally &#123;
            System.out.println(&quot;finally代码块的代码都会执行&quot;);
        &#125;
    &#125;
</code></pre>
<h4 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h4><p>主动创造异常<br>出现在方法内</p>
<pre><code>try&#123;
        Test t = null;
        if(t == null)&#123;
            throw new NullPointerException();
        &#125;
    &#125;catch(Exception e)&#123;
        e.printStackTrace();
    &#125;
</code></pre>
<h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><p>抛出异常<br>出现在方法的声明中</p>
<pre><code>public void what()throws ClassNotFoundException&#123;
        can();
    &#125;
    public void can() throws ClassNotFoundException&#123;
        i();
    &#125;
    public void i()throws ClassNotFoundException&#123;
        Class.forName(&quot;com.iweb.test4.Test&quot;);
    &#125;

    public static void main(String[] args) &#123;
        try &#123;
            new TestThrows().what();
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
</code></pre>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><pre><code>public class JerkException extends Throwable &#123;
    public JerkException(String message)&#123;
        super(message);
    &#125;
&#125;

String name=&quot;jzy&quot;;
        try &#123;
            if(name.equals(&quot;jzy&quot;))&#123;
                throw new JerkException(&quot;终于找到你了，渣男，tui！&quot;);
            &#125;
        &#125;catch (JerkException e)&#123;
            e.printStackTrace();
        &#125;
</code></pre>
<h2 id="代码分层（规范）"><a href="#代码分层（规范）" class="headerlink" title="代码分层（规范）"></a>代码分层（规范）</h2><h3 id="pojo层"><a href="#pojo层" class="headerlink" title="pojo层"></a>pojo层</h3><p>用于存放非规则实体类</p>
<h3 id="view层"><a href="#view层" class="headerlink" title="view层"></a>view层</h3><p>用于存放操作视图</p>
<h3 id="service层"><a href="#service层" class="headerlink" title="service层"></a>service层</h3><p>用于存放服务层面的接口类</p>
<h3 id="controller层"><a href="#controller层" class="headerlink" title="controller层"></a>controller层</h3><p>用于存放控制类</p>
<h3 id="util层"><a href="#util层" class="headerlink" title="util层"></a>util层</h3><p>用于存放工具类</p>
<h3 id="DAO层"><a href="#DAO层" class="headerlink" title="DAO层"></a>DAO层</h3><p>用于存放底层实现方法接口</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>List Set Map</p>
<p>1.扩容相关的操作由集合类自己实现<br>2.提供了丰富的方法，简化了操作的流程<br>3.性能一定没有原生数组好</p>
<h3 id="Collection-单列集合"><a href="#Collection-单列集合" class="headerlink" title="Collection 单列集合"></a>Collection 单列集合</h3><h4 id="集合方法"><a href="#集合方法" class="headerlink" title="集合方法"></a>集合方法</h4><pre><code>Collection a=new ArrayList();
a.add(&quot;a&quot;);//添加
a.add(&quot;b&quot;);
a.add(&quot;c&quot;);
System.out.println(a);
a.remove(&quot;b&quot;);//去除
System.out.println(a);
System.out.println(a.contains(&quot;c&quot;));//检查包含
a.clear();//清空
System.out.println(a.isEmpty());//检查为空
Collection b=new ArrayList();
Collection c=new ArrayList();
b.add(&quot;a&quot;);
b.add(&quot;b&quot;);
b.add(&quot;c&quot;);
c.add(&quot;a&quot;);
c.add(&quot;b&quot;);
System.out.println(b.containsAll(c));//检查b是否全包含c
b.addAll(c);//全加进去
b.removeAll(c);//移除b中和c相同的元素
System.out.println(b.size());//b的尺寸
</code></pre>
<h4 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h4><pre><code>Collection&lt;String&gt; a = new ArrayList();
a.add(&quot;a&quot;);
a.add(1);//error
a.add(new Object());//error
</code></pre>
<h4 id="动态范型"><a href="#动态范型" class="headerlink" title="动态范型"></a>动态范型</h4><pre><code>Person&lt;Dog&gt; person=new Person&lt;&gt;();
person.setFriend(new Dog());
person.getFriend().eat();
Person&lt;Cat&gt; yzx=new Person&lt;&gt;();
yzx.setFriend(new Cat());
yzx.getFriend().sleep();
</code></pre>
<!---->

<pre><code>public class Person&lt;T&gt; &#123;
    String name;
    int age;
    T friend;
    public T getFriend()&#123;
        return friend;
    &#125;
    public void setFriend(T friend)&#123;
        this.friend = friend;
    &#125;
&#125;
</code></pre>
<!---->

<pre><code>public class Dog &#123;
    public void eat() &#123;
        System.out.println(&quot;吃老八&quot;);
    &#125;
&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Cat &#123;</span><br><span class="line">    public void sleep()&#123;</span><br><span class="line">        System.out.println(&quot;猫吃完就睡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>ArrayList LinkedList Vector<br>数组 链表 栈 队列</p>
<h5 id="List接口共性"><a href="#List接口共性" class="headerlink" title="List接口共性"></a>List接口共性</h5><p>1.有序集合（存储和取出的元素顺序相同）<br>2.允许存储重复的元素<br>3.有下标，可以使用普通的for循环进行遍历</p>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p>数组</p>
<h6 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h6><pre><code>List&lt;String&gt; stringlist = new ArrayList&lt;&gt;();
stringlist.add(&quot;lxy晚上提问&quot;);
stringlist.add(&quot;jzy笑了,晚上也提问&quot;);
stringlist.add(&quot;小王车没了,麻了&quot;);
//1.传统for循环
for(int i=0;i&lt;stringlist.size();i++)&#123;
    System.out.print(stringlist.get(i)+&quot;\t&quot;);
&#125;
System.out.println();
//2.增强for循环
for(String s:stringlist)&#123;
    System.out.print(s+&quot;\t&quot;);
&#125;
System.out.println();
//3.迭代器遍历
Iterator&lt;String&gt; iterator = stringlist.iterator();
while(iterator.hasNext())&#123;
    String element = iterator.next();
    System.out.print(element+&quot;\t&quot;);
&#125;
System.out.println();
</code></pre>
<h6 id="删除指定元素"><a href="#删除指定元素" class="headerlink" title="删除指定元素"></a>删除指定元素</h6><pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add(&quot;a&quot;);
list.add(&quot;b&quot;);
list.add(&quot;c&quot;);
list.add(&quot;d&quot;);
list.add(&quot;e&quot;);
list.add(&quot;f&quot;);
list.add(&quot;g&quot;);
Iterator it=list.iterator();
while(it.hasNext())&#123;
    String element = (String) it.next();
    if(element.equals(&quot;c&quot;))&#123;
        //list.remove(element);//数量异常
        it.remove();
    &#125;
&#125;



//普通for循环（不推荐）
for(int i=0;i&lt;list.size();i++)&#123;
    if(list.get(i).equals(&quot;c&quot;))&#123;
        list.remove(list.get(i));
    &#125;
&#125;
</code></pre>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p>链表<br>存在下标，可以在开发中使用，但实际上还是使用地址查询，查询速度不如数组快</p>
<h6 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h6><p>单向链表</p>
<pre><code>Queue&lt;String&gt; queue=new LinkedList&lt;&gt;();
queue.offer(&quot;a&quot;);
queue.offer(&quot;b&quot;);
queue.offer(&quot;c&quot;);
System.out.println(queue.poll());//取出并删除
System.out.println(queue.peek());//取出
System.out.println(queue);//遍历打印
</code></pre>
<h6 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h6><p>双向链表</p>
<pre><code>Deque&lt;String&gt; queue=new LinkedList&lt;&gt;();
queue.offer(&quot;a&quot;);
queue.offer(&quot;b&quot;);
queue.offer(&quot;c&quot;);
queue.offerFirst(&quot;d&quot;);//开头插入
queue.offerLast(&quot;e&quot;);//结尾插入
System.out.println(queue);
System.out.println(queue.pollFirst());//取出并删除开头元素
System.out.println(queue.pollLast());//取出并删除结尾元素
System.out.println(queue);
System.out.println(queue.peekFirst());//取出开头元素
System.out.println(queue.peekLast());//取出结尾元素
System.out.println(queue);
</code></pre>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>HashSet TreeSet LinkedHashSet</p>
<h5 id="Set接口共性"><a href="#Set接口共性" class="headerlink" title="Set接口共性"></a>Set接口共性</h5><p>1.不允许存储重复元素<br>2.没有下标，无法通过传统for循环遍历<br>3.不保证存储顺序和读取顺序一致</p>
<h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>底层是HashMap &#x3D;&gt; hash散列</p>
<pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();
set.add(&quot;a&quot;);
set.add(&quot;b&quot;);
set.add(&quot;b&quot;);
set.add(&quot;b&quot;);
set.add(&quot;c&quot;);
set.add(&quot;d&quot;);
Iterator&lt;String&gt; it = set.iterator();
while (it.hasNext()) &#123;
    String element = it.next();
    System.out.println(element);
&#125;
</code></pre>
<h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>底层是TreeMap&#x3D;&gt;红黑树（排序二叉树）<br>可以对存入的数据进行自动排序，排序是有要求的，要么泛型类型实现了Comparable接口，要么在创建TreeSet的时候传入一个Comparator对象。</p>
<p>定义数据的排序基准 比较器</p>
<pre><code>public class Stu implements Comparable&lt;Stu&gt; &#123;
    private String name;
    private int age;
    private int height;
    @Override
    public int compareTo(Stu o) &#123;
        if(this.age&gt;o.age)&#123;
            return 1;
        &#125;else if(this.age&lt;o.age)&#123;
            return -1;
        &#125;else&#123;
            return 0;
        &#125;
    &#125;
&#125;
------------------
TreeSet&lt;Stu&gt; stuTreeSet=new TreeSet&lt;&gt;();
stuTreeSet.add(new Stu(&quot;jzy&quot;,18,180));
stuTreeSet.add(new Stu(&quot;jzy&quot;,19,189));
stuTreeSet.add(new Stu(&quot;jzy&quot;,20,187));
stuTreeSet.add(new Stu(&quot;jzy&quot;,12,185));
System.out.println(stuTreeSet);
</code></pre>
<!---->

<pre><code>public class Teacher &#123;
    private String name;
    private int age;
    private int height;
&#125;
---------------------
public class TeacherAgeAscComparator implements Comparator&lt;Teacher&gt; &#123;
    @Override
    public int compare(Teacher o1, Teacher o2) &#123;
        if(o1.getAge() &gt; o2.getAge())&#123;
            return 1;
        &#125;else if(o1.getAge() &lt; o2.getAge())&#123;
            return -1;
        &#125;else &#123;
            return 0;
        &#125;
    &#125;
&#125;
-------------------
Comparator&lt;Teacher&gt; c=new TeacherAgeAscComparator();
TreeSet&lt;Teacher&gt; teacherTreeSet=new TreeSet&lt;&gt;(c);
teacherTreeSet.add(new Teacher(&quot;王老师&quot;,18,188));
teacherTreeSet.add(new Teacher(&quot;王老师&quot;,16,188));
teacherTreeSet.add(new Teacher(&quot;王老师&quot;,19,188));
teacherTreeSet.add(new Teacher(&quot;王老师&quot;,40,188));
teacherTreeSet.add(new Teacher(&quot;王老师&quot;,39,188));
System.out.println(teacherTreeSet);
</code></pre>
<h6 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h6><pre><code>TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;();
ts.add(3);
ts.add(5);
ts.add(1);
ts.add(2);
ts.add(4);
System.out.println(ts.ceiling(3));//&gt;=
System.out.println(ts.higher(3));//&gt;
System.out.println(ts.floor(3));//&lt;=
System.out.println(ts.lower(3));//&lt;
</code></pre>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>存读有序<br>读取顺序和存储顺序一致</p>
<h4 id="Collection方法工具类"><a href="#Collection方法工具类" class="headerlink" title="Collection方法工具类"></a>Collection方法工具类</h4><h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><p>该工具类的sort方法进行排序是有要求的<br>要么排序的集合泛型类型实现了Comporable接口，要么在调用sort方法的时候传入一个Comporator对象</p>
<pre><code>List&lt;Teacher&gt; list=new ArrayList&lt;&gt;();
list.add(new Teacher(&quot;王老师&quot;,18,188));
list.add(new Teacher(&quot;王老师&quot;,16,188));
list.add(new Teacher(&quot;王老师&quot;,19,188));
list.add(new Teacher(&quot;王老师&quot;,40,188));
list.add(new Teacher(&quot;王老师&quot;,39,188));
Comparator&lt;Teacher&gt; c=new TeacherAgeAscComparator();
Collections.sort(list,c);
System.out.println(list);
</code></pre>
<h5 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h5><p>打乱随机</p>
<pre><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
for(int i = 1; i &lt;= 10; i++) &#123;
    list.add(i);
&#125;
System.out.println(list);
Collections.shuffle(list);
System.out.println(list);
</code></pre>
<h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><p>倒置</p>
<pre><code>Collections.reverse(list);
System.out.println(list);
</code></pre>
<h5 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h5><p>交换位置</p>
<pre><code>Collections.swap(list,3,7);
System.out.println(list);
</code></pre>
<h5 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h5><p>移位</p>
<pre><code>Collections.rotate(list,3);
System.out.println(list);
</code></pre>
<h3 id="Map-双列集合-key-value"><a href="#Map-双列集合-key-value" class="headerlink" title="Map 双列集合 key value"></a>Map 双列集合 key value</h3><p>HashMap TreeMap HashTable CancurrentHashMap(手撕HashMap)</p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>底层是Hash散列</p>
<pre><code>Map&lt;Key,Value&gt; map=new HashMap&lt;&gt;();
map.put(&quot;jerk&quot;,&quot;jzy&quot;);
map.put(&quot;feiyangyang&quot;,&quot;whw&quot;);
map.put(&quot;西格玛&quot;,&quot;tjh&quot;);
map.put(&quot;西格玛&quot;,&quot;whw&quot;);
System.out.println(map.get(&quot;西格玛&quot;));//Key
System.out.println(map);
</code></pre>
<p>key可以是null，value也可以是null</p>
<pre><code>map.put(null,&quot;hetui&quot;);
map.put(null,&quot;a?&quot;);
System.out.println(map);
</code></pre>
<h5 id="三种遍历方式"><a href="#三种遍历方式" class="headerlink" title="三种遍历方式"></a>三种遍历方式</h5><h6 id="根据增强for循环遍历"><a href="#根据增强for循环遍历" class="headerlink" title="根据增强for循环遍历"></a>根据增强for循环遍历</h6><p>根据keySet遍历</p>
<pre><code>for(String key:map.keySet())&#123;
    System.out.println(key+&quot;:&quot;+map.get(key));
&#125;
Iterator&lt;String&gt; keySet = map.keySet().iterator();
while(keySet.hasNext())&#123;
    String key = keySet.next();
    System.out.println(key+&quot;:&quot;+map.get(key));
&#125;
</code></pre>
<p>根据entrySet遍历</p>
<pre><code>for(Map.Entry&lt;String,String&gt; entry:map.entrySet())&#123;
    System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());
&#125;
Iterator&lt;Map.Entry&lt;String,String&gt;&gt; iterator = map.entrySet().iterator();
while(iterator.hasNext())&#123;
    Map.Entry&lt;String,String&gt; entry = iterator.next();
    System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());
&#125;
</code></pre>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>默认是升序排列所有的键值对 根据key排序<br>需要key所对应的类实现Comparable接口，或者提供Comparator作为构造函数的参数<br>底层是二叉树（红黑树）。</p>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><pre><code>TreeMap&lt;Integer, String&gt; treemap = new TreeMap&lt;&gt;();
treemap.put(2, &quot;b&quot;);
treemap.put(5, &quot;e&quot;);
treemap.put(3, &quot;c&quot;);
treemap.put(1, &quot;a&quot;);
treemap.put(4, &quot;d&quot;);
System.out.println(treemap);
System.out.println(treemap.lowerEntry(3));
System.out.println(treemap.lowerKey(3));
System.out.println(treemap.higherEntry(3));
System.out.println(treemap.higherKey(3));
System.out.println(treemap.floorEntry(3));
System.out.println(treemap.floorKey(3));
System.out.println(treemap.ceilingEntry(3));
System.out.println(treemap.ceilingKey(3));
System.out.println(treemap.firstKey());
System.out.println(treemap.lastKey());
System.out.println(treemap.firstEntry());
System.out.println(treemap.lastEntry());
</code></pre>
<h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><p>key和value不能为空</p>
<h4 id="CancurrentHashMap"><a href="#CancurrentHashMap" class="headerlink" title="CancurrentHashMap"></a>CancurrentHashMap</h4><p>线程安全且性能好，其他跟HashMap类似</p>
<h3 id="学习集合的目标"><a href="#学习集合的目标" class="headerlink" title="学习集合的目标"></a>学习集合的目标</h3><p>1.会使用集合存储数据<br>2.关于遍历集合，能够取出数据<br>3.掌握每种集合的特性</p>
<h3 id="集合框架的学习方式"><a href="#集合框架的学习方式" class="headerlink" title="集合框架的学习方式"></a>集合框架的学习方式</h3><p>1.学习顶层接口中共性方法，因为父接口的所有方法子类必须交继承<br>2.使用顶层，不管接口如何定义，最终实现一定是落在底层的实现类中实现</p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>hash数列 Tree 树 二叉排序树 中序遍历（红黑树）</p>
<h3 id="集合泛型使用"><a href="#集合泛型使用" class="headerlink" title="集合泛型使用"></a>集合泛型使用</h3><p>&lt;&gt;List&lt;XX&gt; xx &#x3D; new ArrayList&lt;XX&gt;(); 动态泛型 T E</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="测试返回值是否与预期一致"><a href="#测试返回值是否与预期一致" class="headerlink" title="测试返回值是否与预期一致"></a>测试返回值是否与预期一致</h3><pre><code>static UserService userservice;
//@After
//@AfterClass
@BeforeClass
public static void init()&#123;
    System.out.println(&quot;初始化完成&quot;);
    userservice = new UserService();
&#125;
@Test
public void test1()&#123;
    //希望验证login的返回值是否和预期一致
    Assert.assertTrue(userservice.login());
&#125;
@Test
public void test2()&#123;
    Assert.assertNotNull(userservice.getDfault());
&#125;
</code></pre>
<h2 id="文件类与IO流"><a href="#文件类与IO流" class="headerlink" title="文件类与IO流"></a>文件类与IO流</h2><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>1.使用绝对路径创建文件对象</p>
<pre><code>File file=new File(&quot;C:/Users/Administrator/Desktop/作业/艾瑞/JavaDemo/jzy.txt&quot;);
System.out.println(file);
</code></pre>
<p>2.相对路径 相对于当前项目的路径创建文件对象</p>
<pre><code>File file1=new File(&quot;C:/Users/Administrator/Desktop/作业/艾瑞/JavaDemo/jzy.txt&quot;);
System.out.println(file);
</code></pre>
<p>3.基于指定目录作为当前文件的父目录</p>
<pre><code>File file2=new File(&quot;C:/Users/Administrator/Desktop/作业/艾瑞/JavaDemo&quot;);
File file3=new File(file2,&quot;b.txt&quot;);
System.out.println(file3.getAbsolutePath());
</code></pre>
<h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><h5 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h5><p>检查文件是否存在</p>
<pre><code>System.out.println(file.exists());
</code></pre>
<h5 id="isDirectory"><a href="#isDirectory" class="headerlink" title="isDirectory"></a>isDirectory</h5><p>检查文件是否为目录</p>
<pre><code>System.out.println(file.isDirectory());
</code></pre>
<h5 id="isFile"><a href="#isFile" class="headerlink" title="isFile"></a>isFile</h5><p>检查文件是否为目录</p>
<pre><code>System.out.println(file.isFile());
</code></pre>
<h5 id="length"><a href="#length" class="headerlink" title="length()"></a>length()</h5><p>获取文件的大小</p>
<pre><code>System.out.println(file.length());
</code></pre>
<h5 id="获取和设置文件的修改时间"><a href="#获取和设置文件的修改时间" class="headerlink" title="获取和设置文件的修改时间"></a>获取和设置文件的修改时间</h5><pre><code>long time=file.lastModified();
Date d=new Date(time);
System.out.println(d);
//设置文件修改时间
file.setLastModified(0);
</code></pre>
<h5 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h5><pre><code>File newfile=new File(&quot;C:/Users/Administrator/Desktop/作业/艾瑞/JavaDemo/zsy.txt&quot;);
file.renameTo(newfile);
System.out.println(file);
</code></pre>
<h5 id="获取文件父目录名称"><a href="#获取文件父目录名称" class="headerlink" title="获取文件父目录名称"></a>获取文件父目录名称</h5><pre><code>String parent=file.getParent();
System.out.println(parent);
</code></pre>
<h5 id="获取父目录的File对象"><a href="#获取父目录的File对象" class="headerlink" title="获取父目录的File对象"></a>获取父目录的File对象</h5><pre><code>File parentFile=file.getParentFile();
System.out.println(parentFile);
</code></pre>
<h5 id="list"><a href="#list" class="headerlink" title="list()"></a>list()</h5><p>以字符串数组的方式 返回当前目录下所有文件的文件名称</p>
<pre><code>String[] list=parentFile.list();
System.out.println(Arrays.asList(list));
</code></pre>
<h5 id="listFile"><a href="#listFile" class="headerlink" title="listFile()"></a>listFile()</h5><p>以File数组的方式 返回当前目录下所有文件的文件对象&lt;NEWLINE&gt;</p>
<pre><code>File[] files=parentFile.listFiles();
</code></pre>
<h5 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h5><p>创建文件对象路径所对应的目录 如果该目录的父目录不存在 则无法创建</p>
<pre><code>File mkdir=new File(&quot;C:/Users/Administrator/Desktop/作业/艾瑞/JavaDemo/cz&quot;);
</code></pre>
<h5 id="mkdirs"><a href="#mkdirs" class="headerlink" title="mkdirs"></a>mkdirs</h5><p>创建文件对象路径所对应的目录 如果父类不存在则一并创建</p>
<pre><code>mkdir.mkdirs();
</code></pre>
<h5 id="creatNewFile"><a href="#creatNewFile" class="headerlink" title="creatNewFile()"></a>creatNewFile()</h5><p>创建一个空白文件,在创建文件之前需要保证文件的父目录存在</p>
<pre><code>file.getParentFile().mkdirs();
file.createNewFile();
</code></pre>
<!---->

<pre><code>Scanner sc = new Scanner(System.in);
System.out.println(&quot;请输入目录：&quot;);
String directory = sc.nextLine();
File file=new File(directory);
for(int i=0;i&lt;100;i++)&#123;
    File f=new File(directory,Sort.getContent());
    f.createNewFile();
&#125;
</code></pre>
<h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><p>删除文件<br>无法删除有文件的目录文件，目录必须为空才能删除</p>
<h5 id="deleteOnExit"><a href="#deleteOnExit" class="headerlink" title="deleteOnExit()"></a>deleteOnExit()</h5><p>在虚拟机退出时删除文件 一般用于临时文件的删除</p>
<h3 id="I-O流"><a href="#I-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h3><p>I input<br>O output<br>流 Stream</p>
<p>InputStream OutputStream</p>
<h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><h5 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h5><pre><code> @Test
    public void testInputStream() &#123;
        try&#123;
            //创建文件对象
            File file=new File(&quot;C:/Users/Administrator/Desktop/作业/艾瑞/JavaDemo/ljy.txt&quot;);
            //创建基于文件对象的字节输入流
            FileInputStream fis=new FileInputStream(file);
            //准备一个字节数组 字节数组的长度和要读取的字节数一致
            byte[] b=new byte[(int)file.length()];
            //将数据从字节输入流中读取到数组中
            fis.read(b);
            //遍历读取结果
            for(byte b1:b)&#123;
                System.out.print(b1+&quot;\t&quot;);
            &#125;
            //使用完成之后需要对流进行关闭节约资源
        &#125;catch(IOException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<h5 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h5><pre><code>public void testInputStream() &#123;
        try&#123;
            //创建文件对象
            File file=new File(&quot;C:/Users/Administrator/Desktop/作业/艾瑞/JavaDemo/ljy.txt&quot;);
            //创建基于文件对象的字节输入流
            FileInputStream fis=new FileInputStream(file);
            //准备一个字节数组 字节数组的长度和要读取的字节数一致
            byte[] b=new byte[(int)file.length()];
            //将数据从字节输入流中读取到数组中
            fis.read(b);
            //遍历读取结果
            for(byte b1:b)&#123;
                System.out.print(b1+&quot;\t&quot;);
            &#125;
            //使用完成之后需要对流进行关闭节约资源
        &#125;catch(IOException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<h5 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h5><pre><code>public void testDownloadFile()&#123;
        HttpURLConnection connection=null;
        InputStream is=null;
        FileOutputStream fos=null;
        String urlPath=&quot;https://dldir1.qq.com/qqfile/qq/QQNT/Windows/QQ_9.9.16_241112_x64_01.exe&quot;;
        try&#123;
            //定义下载链接对象（统一资源定位符）
            URL url=new URL(urlPath);
            //获取httpURLConnection对象
            connection=(HttpURLConnection)url.openConnection();
            //根据链接获取对应的输入流
            is=connection.getInputStream();
            //定义下载文件的文件对象
            File file=new File(&quot;C:/Users/Administrator/Desktop/作业/艾瑞/JavaDemo/&quot;+urlPath.substring(urlPath.lastIndexOf(&quot;/&quot;)+1));
            //定义对应的输出流
            fos=new FileOutputStream(file);
            //定义缓存数组
            byte[] buffer=new byte[1024];
            int len;
            while((len=is.read(buffer))!=-1)&#123;
                fos.write(buffer,0,len);
            &#125;
            System.out.println(&quot;下载完毕！&quot;);
        &#125;catch(Exception e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><h5 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h5><pre><code>public void testFileReader()&#123;
        File f=new File(&quot;C:/Users/Administrator/Desktop/作业/艾瑞/JavaDemo/ljy.txt&quot;);
        try(FileReader fr=new FileReader(f))&#123;
            char[] c=new char[(int)f.length()];
            fr.read(c);
            for(char c1:c)&#123;
                if(c1==&#39;\u0000&#39;)&#123;
                    break;
                &#125;
                System.out.print(c1);
            &#125;
        &#125;catch(IOException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<h5 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h5><pre><code>public void testFileWriter()&#123;
        File f=new File(&quot;C:/Users/Administrator/Desktop/作业/艾瑞/JavaDemo/ljy.txt&quot;);
        try(FileWriter fw=new FileWriter(f,true))&#123;
            String str=&quot;爱笑的男生运气不太差哦&quot;;
            fw.write(str.toCharArray());
        &#125;catch(IOException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<h4 id="缓存流"><a href="#缓存流" class="headerlink" title="缓存流"></a>缓存流</h4><p>java帮我们封装了缓存的操作，减少了IO操作的次数，提高了磁盘性能</p>
<h5 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h5><pre><code>@Test
    public void testBufferedReader()&#123;
        File f=new File(&quot;C:/Users/Administrator/Desktop/作业/艾瑞/JavaDemo/ljy.txt&quot;);
        try(FileReader fr=new FileReader(f))&#123;
            BufferedReader br=new BufferedReader(fr);
            while(true)&#123;
                String line=br.readLine();
                if(line==null)&#123;
                    break;
                &#125;
                System.out.println(line);
            &#125;
        &#125;catch(IOException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<h5 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h5><p>只能操作文本</p>
<pre><code>@Test
    public void testPrintWriter()&#123;
        File f=new File(&quot;C:/Users/Administrator/Desktop/作业/艾瑞/JavaDemo/ljy.txt&quot;);
        try(FileWriter fw=new FileWriter(f,true);
        PrintWriter pw=new PrintWriter(fw))&#123;
            pw.println(&quot;whw觉得今天作业甚少&quot; );
            pw.println(&quot;管老师懂了&quot;);
            pw.println(&quot;这就超级加倍&quot;);
            //pw.flush();
        &#125;catch(IOException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>用于需要进行标准格式化输入输出的场景，即指定数据类型传输 后续会在socket编程中使用到</p>
<h5 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h5><p>数据输入流只能读取由数据输出流所写入的数据,否则就会出现EOFException</p>
<pre><code>@Test
    public void testDataInputStream()&#123;
        File f=new File(&quot;C:/Users/Administrator/Desktop/作业/艾瑞/JavaDemo/ljy.txt&quot;);
        try(FileInputStream fis=new FileInputStream(f);
        DataInputStream dis=new DataInputStream(fis))&#123;
            System.out.println(dis.readUTF());
            System.out.println(dis.readBoolean());
            System.out.println(dis.readInt());
        &#125;catch (IOException E)&#123;
            E.printStackTrace();
        &#125;
    &#125;
</code></pre>
<h5 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h5><pre><code>@Test
    public void testDataOutputStream()&#123;
        File f=new File(&quot;C:/Users/Administrator/Desktop/作业/艾瑞/JavaDemo/ljy.txt&quot;);
        try(FileOutputStream fos=new FileOutputStream(f);
            DataOutputStream dos=new DataOutputStream(fos))&#123;
            dos.writeUTF(&quot;whw觉得今天作业很少&quot;);
            dos.writeBoolean(true);
            dos.writeInt(100);
        &#125;catch(IOException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<h4 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h4><h5 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h5><p>将Java对象转化为特殊的二进制字节码或者字符串的过程</p>
<h5 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h5><p>将特殊的二进制字节码合作和字符串还原成Java对象的过程</p>
<h5 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h5><h5 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h5><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>java用于数据库可以和java连接的一套接口规范<br>JDBC java database connection</p>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><p>Connection</p>
<blockquote>
<p>JDBC 第一步<br>加载驱动</p>
</blockquote>
<pre><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
System.out.println(&quot;驱动加载成功&quot;);
</code></pre>
<blockquote>
<p>第二步<br>获取连接</p>
</blockquote>
<pre><code>String jdbcurl=&quot;jdbc:mysql://localhost:3307/nuist?characterEncoding=utf8&quot;;
String username=&quot;root&quot;;
String password=&quot;a12345&quot;;
Connection c = DriverManager.getConnection(jdbcurl, username, password);
System.out.println(&quot;获取连接成功&quot;);
</code></pre>
<blockquote>
<p>第三步<br>获取编译语句 并准备sql语句</p>
</blockquote>
<pre><code>Statement s = c.createStatement();
String sql =&quot; insert into student(name,age)values(&#39;yzx&#39;,18)&quot;;
</code></pre>
<blockquote>
<p>第四步 语句<br>执行insert delete update 使用execute方法<br>如果执行查询语句 使用executeQuery</p>
</blockquote>
<pre><code>s.execute(sql);
</code></pre>
<blockquote>
<p>Statement 编译语句对象存在sql注入和效率低下的问题<br>先传参 再编译</p>
</blockquote>
<pre><code>select * from user where username =&#39;%s&#39; and password = &#39;a&#39; or 1=1;
</code></pre>
<blockquote>
<p>PreparedStatement 预编译语句 可以有效防止Sql注入攻击问题<br>先编译 再传参 你传入的所有参数 不管是否包含sql语句的关键字 都只会被当做字符串进行处理<br>Statement由于先传参再编译的特性 导致哪怕相同的sql语句 都需要重复编译<br>假设要连续执行1w条insert语句 Statement就会编译1w次<br>如果是PreparedStatement 只需要编译一次</p>
</blockquote>
<pre><code>try(Connection c=DBUtil.getConnection();
    PreparedStatement ps=c.prepareStatement(sql);)&#123;
    ps.setInt(1,id);
    //结果集 类似于数据库的游标
    ResultSet rs=ps.executeQuery();
    if(rs.next())&#123;
    s.setId(rs.getInt(&quot;id&quot;));
    s.setName(rs.getString(2));
    s.setAge(rs.getInt(&quot;age&quot;));
    return s;
    &#125;
&#125;catch (Exception e)&#123;
    e.printStackTrace();
&#125;
</code></pre>
<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><blockquote>
<p>ORM object relation model<br>一个实体类映射数据库的一张表<br>一个属性映射表中的一个字段<br>java中的一个实体类对象映射表中的一行数据<br>java中的一个集合 例如List&lt;Student&gt;映射表中的多行数据</p>
</blockquote>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="单核单CPU"><a href="#单核单CPU" class="headerlink" title="单核单CPU"></a>单核单CPU</h3><p>单一进程 轮询机制</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><blockquote>
<p>线程对象创建方式<br>1.继承Thread类<br>2.实现Runnable接口<br>3.实现Collable接口<br>4.实现Future接口<br>5.从线程池中后驱线程对象<br>6.使用匿名内部类快速创建线程对象</p>
</blockquote>
<h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><pre><code>public class TestThread extends Thread &#123;
    public TestThread(String name) &#123;
        super(name);
    &#125;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.println(&quot;老师作业太多了，能不能加一点。来自：&quot;+getName());
        &#125;
    &#125;
&#125;
</code></pre>
<p>线程对象在进入到启动状态之后会自动调用run方法<br>但是开发者不可以使用t1.run()的方式调用线程的run方法 这样的调用会失去线程特性<br>java中 所有的线程需要被JVM分配运行资源才可以自动执行run方法<br>所有的线程需要调用start方法来进入就绪态<br>只有就绪态的线程 才有机会被JVM分配运行资源并执行线程run方法</p>
<pre><code>public static void main(String[] args) &#123;
TestThread t1=new TestThread(&quot;王宏伟&quot;);
TestThread t2=new TestThread(&quot;靳振宇&quot;);
TestThread t3=new TestThread(&quot;李佳雨&quot;);
t1.start();
t2.start();
t3.start();
System.out.println(&quot;main方法对应的主线程运行结束&quot;);
&#125;
</code></pre>
<h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><p>Runnable的实现类不可以直接用于创建线程 需要借用Thread类进行实例化</p>
<pre><code>public class TestThread implements Runnable &#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.println(&quot;太好了，牢管让我少做20题牛客网，我是：&quot;+Thread.currentThread().getName());
        &#125;
    &#125;
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        TestThread tt1 = new TestThread();
        Thread t1 = new Thread(tt1);
        TestThread tt2 = new TestThread();
        Thread t2 = new Thread(tt2);
        TestThread tt3 = new TestThread();
        Thread t3 = new Thread(tt3);
        t1.setName(&quot;李佳雨&quot;);
        t2.setName(&quot;靳振宇&quot;);
        t3.setName(&quot;王宏伟&quot;);
        t1.start();
        t2.start();
        t3.start();

    &#125;
&#125;
</code></pre>
<h4 id="使用匿名内部类创建线程对象"><a href="#使用匿名内部类创建线程对象" class="headerlink" title="使用匿名内部类创建线程对象"></a>使用匿名内部类创建线程对象</h4><p>本质还是继承Thread 换了个写法</p>
<pre><code>public static void main(String[] args) &#123;
    Thread t1 = new Thread() &#123;
        public void run() &#123;
            for (int i = 1; i &lt;= 10; i++) &#123;
                System.out.println(&quot;牛客网+20题，我是&quot; + this.getName());
            &#125;
        &#125;
    &#125;;
    t1.setName(&quot;王宏伟&quot;);
    Thread t2 = new Thread() &#123;
        public void run() &#123;
            for (int i = 1; i &lt;= 10; i++) &#123;
                System.out.println(&quot;牛客网+20题，我是&quot; + this.getName());
            &#125;
        &#125;
    &#125;;
    t2.setName(&quot;李佳雨&quot;);
    t1.start();
    t2.start();
&#125;
</code></pre>
<h3 id="进程休眠"><a href="#进程休眠" class="headerlink" title="进程休眠"></a>进程休眠</h3><p>sleep方法会使当前线程暂停运行并且放弃CPU资源<br>其他线程可以在其sleep的期间内获取CPU的调度资源</p>
<pre><code>public class Test &#123;
    public static void main(String[] args) &#123;
        Thread t1=new Thread()&#123;
            @Override
            public void run() &#123;
                int times=0;
                while(true)&#123;
                    try&#123;
                        System.out.println(&quot;李佳雨要休眠了&quot;);
                        Thread.sleep(100);
                        System.out.println(&quot;李佳雨苏醒了&quot;);
                    &#125;catch (InterruptedException e)&#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;
        &#125;;
        Thread t2=new Thread()&#123;
            @Override
            public void run() &#123;
                while(true)&#123;
                    System.out.println(&quot;我是徐亮，我竞争到CPU资源了&quot;);
                &#125;
            &#125;
        &#125;;
        t1.start();
        t2.start();
        System.out.println(&quot;主线程结束&quot;);
    &#125;
&#125;    
</code></pre>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>类似于插队<br>被join的线程需要等待其他线程运行结束之后 才会继续运行</p>
<pre><code>public class Test &#123;
    public static void main(String[] args) &#123;
        Thread t1=new Thread()&#123;
            public void run()&#123;
                for(int i=1;i&lt;=10;i++)&#123;
                    System.out.println(getName()+&quot;在执行线程方法&quot;);
                &#125;
            &#125;
        &#125;;
        t1.setName(&quot;李佳雨&quot;);
        Thread t2=new Thread()&#123;
            public void run()&#123;
                for(int i=1;i&lt;=10;i++)&#123;
                    System.out.println(getName()+&quot;在执行线程方法&quot;);
                &#125;
            &#125;
        &#125;;
        t2.setName(&quot;王宏伟&quot;);
        t1.start();
        t2.start();
        try &#123;
            //t1线程join了主线程
            //在t1线程运行结束之前 主线程不会运行
            //直到t1线程运行结束 主线程才会从join的位置继续往下运行
            t1.join();
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
        System.out.println(&quot;主线程执行完毕&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>优先级更高的线程有更大的几率优先执行<br>但是需要在样本数量足够多的情况下才能体现</p>
<pre><code>public class Test &#123;
    public static void main(String[] args) &#123;
//        System.out.println(Thread.MAX_PRIORITY);
//        System.out.println(Thread.MIN_PRIORITY);
        //线程的优先级必须在线程进入到就绪态之前设置才有效
        Thread t1 = new Thread() &#123;
            public void run() &#123;
                for (int i = 0; i &lt; 1000; i++) &#123;
                    System.out.println(&quot;徐亮开始run&quot;);
                &#125;
            &#125;
        &#125;;
        Thread t2 = new Thread() &#123;
            public void run() &#123;
                for (int i = 0; i &lt; 1000; i++) &#123;
                    System.out.println(&quot;黄厚宏开始run&quot;);
                &#125;
            &#125;
        &#125;;
        t1.setPriority(1);
        t2.setPriority(10);
        t1.start();
        t2.start();
    &#125;
&#125;
</code></pre>
<h3 id="让步"><a href="#让步" class="headerlink" title="让步"></a>让步</h3><pre><code>public class Test &#123;
    public static void main(String[] args) &#123;
        Thread t1 = new Thread()&#123;
            public void run()&#123;
                for(int i=1;i&lt;=10;i++)&#123;
                    System.out.println(&quot;王宏伟run起来了&quot;+i);
                &#125;
            &#125;
        &#125;;
        Thread t2 = new Thread()&#123;
            public void run()&#123;
                for(int i=1;i&lt;=10;i++)&#123;
                    System.out.println(&quot;李佳雨run起来了&quot;+i);
                    //线程让步
                    Thread.yield();
                &#125;
            &#125;
        &#125;;
        t1.start();
        t2.start();
    &#125;
&#125;
</code></pre>
<h3 id="守护"><a href="#守护" class="headerlink" title="守护"></a>守护</h3><p>守护线程会在所有其他费守护线程运行结束之后停止运行<br>GC的本质是守护线程</p>
<pre><code>public class Test &#123;
    public static void main(String[] args) &#123;
        Thread t1 = new Thread()&#123;
            public void run()&#123;
                int times=0;
                while(true)&#123;
                    try &#123;
                        Thread.sleep(1000);
                    &#125; catch (InterruptedException e) &#123;
                        throw new RuntimeException(e);
                    &#125;
                    System.out.println(&quot;守护线程已经执行了&quot;+(++times)+&quot;秒&quot;);
                &#125;
            &#125;
        &#125;;
        Thread t2 = new Thread()&#123;
            public void run()&#123;
                for(int i=1;i&lt;=10;i++)&#123;
                    System.out.println(&quot;我是线程t2，我运行的循环次数为：&quot;+i);
                &#125;
            &#125;
        &#125;;
        //将t1标记为守护线程
        t1.setDaemon(true);
        t1.start();
        t2.start();
        //主线程sleep20000ms 延迟主线程运行时间
        System.out.println(&quot;主线程开始sleep&quot;);
        try&#123;
            Thread.sleep(20000);
        &#125;catch(Exception e)&#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;主线程运行结束&quot;);
    &#125;
&#125;
</code></pre>
<p>t1为t2和主线程的守护线程，在t2和主线程跑完前t1会一直跑，即使是死循环t1也会在t2和主线程跑完后结束</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><pre><code>public class Ticket &#123;
    private Integer ticketNo;
&#125;
public class TicketShop &#123;
    private List&lt;Ticket&gt; ticketBox;
    public TicketShop() &#123;
        //对票箱进行初始化 并且装满票
        ticketBox = new ArrayList&lt;&gt;();
        for (int i = 1; i &lt; 6; i++) &#123;
            ticketBox.add(new Ticket(i));
        &#125;
    &#125;
    public synchronized Ticket getTicket() &#123;
        if(ticketBox.isEmpty())&#123;
            return null;
        &#125;
        Ticket targetTicket = ticketBox.get(0);
        ticketBox.remove(targetTicket);
        return targetTicket;
    &#125;
&#125;
public class IKUNThread extends Thread &#123;
    private TicketShop ticketShop;

    public IKUNThread(TicketShop ticketShop, String name) &#123;
        super(name);
        this.ticketShop = ticketShop;
    &#125;
    
    public void run() &#123;
        synchronized (ticketShop) &#123;
            Ticket ticket = ticketShop.getTicket();
            if (ticket != null) &#123;
                System.out.println(&quot;ikun&quot; + getName() + &quot;抢到了&quot; + ticket);
            &#125;
    &#125;
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        TicketShop ticketShop = new TicketShop();
        List&lt;IKUNThread&gt; IKUNThreads = new ArrayList&lt;&gt;();
        for(int i = 1; i &lt;= 500; i++)&#123;
            IKUNThreads.add( new IKUNThread(ticketShop,&quot;IKUN&quot;+i));
        &#125;
        for(IKUNThread ikunThread : IKUNThreads)&#123;
            ikunThread.start();
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>ticketShop是多线程所竞争的资源对象,被多线程竞争的资源对象也叫做同步对象<br>每一个同步对象都有一个锁，在总线程在进入到synchronized代码块之后就会获得这个同步对象的锁<br>锁会在线程执行完被synchronized锁修饰的方法运行完成之后被释放<br>其他线程在没有持有锁的情况下无法进入到synchronized代码块中,这种情况叫被阻塞</p>
</blockquote>
<h4 id="线程的交互"><a href="#线程的交互" class="headerlink" title="线程的交互"></a>线程的交互</h4><p>三个方法 wait notify notifyAll<br>这三个方法并不是通过线程调用的，而是通过同步对象调用的。而任意对象都可以定义为同步对象，所以这三个线程交互的方法都定义在Object类中</p>
<blockquote>
<p>wait方法的作用是让占有着当前同步对象锁的线程 进入等待状态并且释放锁<br>wait方法一般只出现在synchronized代码块中<br>处于wait状态的线程如果没有同步对象调用notify方法唤醒 就会一直处于wait状态</p>
</blockquote>
<blockquote>
<p>notify作用是通知一个被当前同步对象wait的线程苏醒过来</p>
</blockquote>
<blockquote>
<p>notifyAll作用是通知所有被当前同步对象wait的线程全部苏醒过来</p>
</blockquote>
<blockquote>
<p>蛮王大招</p>
</blockquote>
<pre><code>public class Monster &#123;
    public String name;
    public int hp;

    public synchronized void recover() &#123;
        hp += 1;
        System.out.println(&quot;为&quot;+name+&quot;回复了一点生命值。当前生命值为：&quot;+hp);
        this.notify();
    &#125;

    public void hurt() &#123;
        synchronized (this) &#123;
            if(hp==1)&#123;
                try &#123;
                    this.wait();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            hp -= 1;
            System.out.println(&quot;对&quot;+name+&quot;造成了一点伤害。当前生命值为：&quot;+hp);
        &#125;
    &#125;
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        Monster monster = new Monster();
        monster.name=&quot;哥布林&quot;;
        monster.hp=500;
        Thread t1 =new Thread()&#123;
            public void run()&#123;
                while(true)&#123;
                    monster.hurt();
                    try &#123;
                        Thread.sleep(10);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;
        &#125;;
        Thread t2 =new Thread()&#123;
            public void run()&#123;
                while(true)&#123;
                    monster.recover();
                    try &#123;
                        Thread.sleep(100);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;
        &#125;;
        t1.start();
        t2.start();
    &#125;
&#125;
</code></pre>
<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><pre><code>public class Egg &#123;
    private Integer id;
&#125;
/*
需要提供一个容器进行装蛋
提供一个取蛋和装蛋的方法
 */
public class Basket &#123;
    int index;
    //定义蛋容器
    Egg[] arrEgg=new Egg[10];
    //装蛋方法
    public synchronized void pushEgg(Egg egg) &#123;
        while(index==arrEgg.length)&#123;
            //如果篮子满了，则让装蛋的哥哥线程进入wait状态
            try &#123;
                Thread.sleep(2000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            try &#123;
                this.wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        this.notify();
        //将当前蛋放入到篮子中
        arrEgg[index]=egg;
        index++;
    &#125;
    public synchronized Egg popEgg() &#123;
        while(index==0)&#123;
            try &#123;
                Thread.sleep(2000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            try &#123;
                this.wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        this.notify();
        index--;
        return arrEgg[index];
    &#125;
&#125;
public class Producer implements Runnable &#123;
    Basket bt;
    public Producer(Basket bt) &#123;
        this.bt = bt;
    &#125;
    public void run() &#123;
        //假设哥哥一共就下20个蛋
        for (int i = 0; i &lt; 20; i++) &#123;
            Egg egg = new Egg(i);
            bt.pushEgg(egg);
            System.out.println(&quot;哥哥新下了一个蛋：&quot;+egg);
        &#125;
        try &#123;
            Thread.sleep(1000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
public class Consumer implements Runnable &#123;
    Basket bt;
    public Consumer(Basket bt) &#123;
        this.bt = bt;
    &#125;
    public void run() &#123;
        //先假设单一ikun一次性也取20个蛋
//        for(int i=0;i&lt;20;i++)&#123;
            Egg egg = bt.popEgg();
            System.out.println(&quot;ikun拿到了哥哥的蛋&quot;+egg);
//        &#125;
    &#125;
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        Basket basket = new Basket();
        Producer p1=new Producer(basket);
//        Consumer c1=new Consumer(basket);
        new Thread(p1).start();
        try &#123;
            Thread.sleep(2000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
//        new Thread(c1).start();
        List&lt;Runnable&gt; consumers = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 20; i++) &#123;
            consumers.add(new Consumer(basket));
        &#125;
        for(Runnable r : consumers) &#123;
            new Thread(r).start();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>线程池的思路和生产者很接近<br>规定生产者负责踢出任务 消费者负责记录任务<br>1.准备一个任务容器<br>2.一次性启动10个消费者线程（固定数量）<br>3.刚开始的时候任务容器是空的，所有的消费者线程wait在这个任务容器上<br>4.直到生产者线程向这个任务容器中丢了一个任务，就会有一个对应的消费者线程被唤醒<br>5.消费者线程取出任务，并且执行，执行之后继续wait，等待下一次任务的来临</p>
<p>这个模型中，消费者线程是不需要创建新的，而是循环使用已经存在的消费者线程</p>
<pre><code>public class ThreadPool &#123;
    //线程池的大小
    int threadPoolSize;
    //定义任务容器 任务容器中的任务 也应该是线程类型
    LinkedList&lt;Runnable&gt; tasks = new LinkedList&lt;&gt;();

    public ThreadPool() &#123;
        //初始化线程池的大小
        threadPoolSize = 10;
        //启动所有的消费者线程
        synchronized (tasks) &#123;
            for (int i = 0; i &lt; threadPoolSize; i++) &#123;
                new TaskConsumeThread(&quot;消费者线程&quot; + i).start();
            &#125;
        &#125;
    &#125;

    //提供add方法 用于消费者向线程池中添加任务
    public void add(Runnable r) &#123;
        synchronized (tasks) &#123;
            tasks.add(r);
            tasks.notifyAll();
        &#125;
    &#125;

    //定义内部类 用来表示消费者线程
    class TaskConsumeThread extends Thread &#123;
        public TaskConsumeThread(String name) &#123;
            super(name);
        &#125;

        //定义内部类的成员变量 用于表示当前所执行的任务
        Runnable task;

        @Override
        public void run() &#123;
            System.out.println(this.getName() + &quot;启动了&quot;);
            //保证消费者线程可以永久运行
            while (true) &#123;
                //保证对象线程安全
                synchronized (tasks) &#123;
                    //做容器是否为空的检查
                    while (tasks.isEmpty()) &#123;
                        //保证被唤醒的线程从wait出继续运行的时候 能够重新判断任务容器是否为空
                        //直到任务容器非空的时候 才会脱离循环
                        try &#123;
                            tasks.wait();
                        &#125; catch (InterruptedException e) &#123;
                            e.printStackTrace();
                        &#125;
                    &#125;
                    //当任务容器不为空 脱离循环之后 从任务容器中取出一个任务 并进行消费
                    task = tasks.removeLast();
                    //唤醒其他被wait的线程;
                    tasks.notifyAll();
                &#125;
                System.out.println(this.getName() + &quot;正在执行任务&quot;);
//                new Thread(task).start();
                task.run();
            &#125;
        &#125;
    &#125;
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        //实例化线程池对象
        ThreadPool pool = new ThreadPool();
        //定义若干个任务线程 用于后续添加到线程池中
        for (int i = 0; i &lt; 5; i++) &#123;
            Runnable task = new Runnable() &#123;
                public void run() &#123;
                    System.out.println(&quot;我是一个任务线程，我莫得感情&quot;);
                &#125;
            &#125;;
            //添加任务到线程中 交给线程池提供的消费者线程进行处理
            pool.add(task);
        &#125;

    &#125;
&#125;
public class TestThread &#123;
    public static void main(String[] args) &#123;
        ThreadPool threadPool = new ThreadPool();
        int sleep=1000;
        while(true)&#123;
            threadPool.add(new Runnable() &#123;
                @Override
                public void run() &#123;
                    System.out.println(&quot;线程池执行任务&quot;);
                    try &#123;
                        Thread.sleep(1000);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;);
            //向线程池中丢入任务 并且不断减少投递任务的间隔
            try &#123;
                Thread.sleep(sleep);
                sleep=sleep&gt;100?sleep-100:100;
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><h4 id="传统JDBC-Connection连接创建带来的问题"><a href="#传统JDBC-Connection连接创建带来的问题" class="headerlink" title="传统JDBC Connection连接创建带来的问题"></a>传统JDBC Connection连接创建带来的问题</h4><p>1.连接的创建和关闭都是非常消耗性能<br>2.单一数据库同时支持的连接总数是有限的</p>
<p>如果多线程的并发量特别大，数据库的连接总数就会消耗光<br>后续线程发起的数据库连接就会失败</p>
<p>数据库连接池的原理和线程池类似<br>预先准备一定数量的Connection连接对象<br>当有用户需要使用的时候 从连接池取出一个连接使用<br>当用户用完之后 将连接归还<br>如果连接池的连接被借用完了 则其他需要连接的线程wait<br>直到有空余连接 再notify唤醒这些线程</p>
<pre><code>public class ConnectionPool &#123;
    List&lt;Connection&gt; cs = new ArrayList&lt;&gt;();
    int size = 0;

    public ConnectionPool(int size) &#123;
        this.size = size;
        init();
    &#125;

    public void init() &#123;
        try &#123;
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            for (int i = 0; i &lt; size; i++) &#123;
                Connection c = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3307/nuist?characterEncoding=utf8&quot;, &quot;root&quot;, &quot;a12345&quot;);
                cs.add(c);
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    public synchronized Connection getConnection() &#123;
        while(cs.isEmpty())&#123;
            try &#123;
                this.wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        Connection c = cs.remove(0);
        return c;
    &#125;
    public synchronized void returnConnection(Connection c) &#123;
        cs.add(c);
        this.notifyAll();
    &#125;
&#125;
public class Test &#123;
    //初始化一个有三条连接的数据库连接池
    //创建100个线程 每个线程都会从连接池中借用连接
    //并且在用完之后归还连接 在拿到连接之后 执行一个耗时1s的sql语句
   static class WorkThread extends Thread &#123;
        private ConnectionPool cp;

        public WorkThread(String name, ConnectionPool cp) &#123;
            super(name);
            this.cp = cp;
        &#125;

        public void run() &#123;
            Connection c = cp.getConnection();
            System.out.println(this.getName() + &quot;:获取到一个连接，并开始工作&quot;);
            try (PreparedStatement ps = c.prepareStatement(&quot;select * from student&quot;)) &#123;
                ps.executeQuery();
                Thread.sleep(1000);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
            cp.returnConnection(c);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        ConnectionPool cp=new ConnectionPool(3);
        for (int i = 0; i &lt; 100; i++) &#123;
            new WorkThread(&quot;线程&quot;+i,cp).start();
        &#125;
        //实际开发的时候我们使用阿里的druid连接池 只需要我们进行配置 不需要再去操心连接的创建和关闭
    &#125;
&#125;
</code></pre>
<h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><p>悲观锁的另一种实现方式，和synchronized类似<br>但是比synchronized更加灵活，可以指定锁对象，并且可以释放锁对象，<br>可以不阻塞线程，可以不加锁。</p>
<pre><code>public class Test &#123;
    public static String now() &#123;
        return new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date());
    &#125;

    public static void log(String msg) &#123;
        System.out.printf(&quot;%s %s %s %n&quot;, now(), Thread.currentThread().getName(), msg);
    &#125;

    public static void main(String[] args) &#123;
        //实例化Lock对象
        Lock lock = new ReentrantLock();
        Thread t1 = new Thread() &#123;
            public void run() &#123;
                try &#123;
                    log(&quot;线程启动&quot;);
                    log(&quot;视图获取对象锁&quot;);
                    lock.lock();
                    log(&quot;获取锁成功，并执行5s的业务操作模拟&quot;);
                    Thread.sleep(5000);
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125; finally &#123;
                    log(&quot;释放对象锁&quot;);
                    lock.unlock();
                &#125;
            &#125;
        &#125;;
        Thread t2 = new Thread() &#123;
            public void run() &#123;
                try &#123;
                    log(&quot;线程启动&quot;);
                    log(&quot;视图获取对象锁&quot;);
                    lock.lock();
                    log(&quot;获取锁成功，并执行5s的业务操作模拟&quot;);
                    Thread.sleep(5000);
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125; finally &#123;
                    log(&quot;释放对象锁&quot;);
                    lock.unlock();
                &#125;
            &#125;
        &#125;;
        t1.setName(&quot;t1&quot;);
        t2.setName(&quot;t2&quot;);
        t1.start();
        try &#123;
            Thread.sleep(2000);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        t2.start();
    &#125;
&#125;
</code></pre>
<!---->

<pre><code>public class Test &#123;
    public static String now() &#123;
        return new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date());
    &#125;

    public static void log(String msg) &#123;
        System.out.printf(&quot;%s %s %s %n&quot;, now(), Thread.currentThread().getName(), msg);
    &#125;

    public static void main(String[] args) &#123;
        //lock对象也可以实现线程交互
        //synchronized 使用的是wait notify notifyAll
        //我们需要先通过Lock对象获取一个特殊的Conditon对象
        //调用该对象的await signal signAll方法
        Lock lock = new ReentrantLock();
        Condition condition = lock.newCondition();
        Thread t1 = new Thread() &#123;
            public void run() &#123;
                try &#123;
                    log(&quot;线程启动&quot;);
                    log(&quot;试图获取锁&quot;);
                    lock.lock();
                    log(&quot;获取锁成功，并且进行5s的业务模拟操作&quot;);
                    Thread.sleep(5000);
                    log(&quot;临时释放锁，并且等待&quot;);
                    condition.await();
                    log(&quot;重新获取锁，并且进行5s的业务模拟操作&quot;);
                    Thread.sleep(5000);
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;finally &#123;
                    log(&quot;释放锁&quot;);
                    lock.unlock();
                &#125;
                log(&quot;线程结束&quot;);
            &#125;
        &#125;;
        Thread t2 = new Thread() &#123;
            public void run() &#123;
                try &#123;
                    log(&quot;线程启动&quot;);
                    log(&quot;试图获取锁&quot;);
                    lock.lock();
                    log(&quot;获取锁成功，并且进行5s的业务模拟操作&quot;);
                    Thread.sleep(5000);
                    log(&quot;唤醒等待中的线程&quot;);
                    condition.signal();
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125; finally &#123;
                    log(&quot;释放锁&quot;);
                    lock.unlock();
                &#125;
                log(&quot;线程结束&quot;);
            &#125;
        &#125;;
        t1.setName(&quot;t1&quot;);
        t2.setName(&quot;t2&quot;);
        t1.start();
        try &#123;
            Thread.sleep(2000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        t2.start();
    &#125;
&#125;
</code></pre>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>Lock接口和synchronized区别</p>
</blockquote>
<p>1.synchronized是JVM提供的锁 是内置关键字，而Lock是JDK提供的锁，synchronized是隐式锁，Lock是显式锁<br>2.Lock可以选择性地获取锁，如果获取不到可以放弃 synchronized是不可以的。借助Lock的该特性，可以很好地规避死锁。但是synchronized必须通过谨慎和良好的设计，才能减少死锁发生<br>3.synchronized在发生异常或者代码块解释的时候，会自动释放锁。但是Lock必须手动释放，如果忘记释放锁，一样会产生死锁。</p>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><blockquote>
<p>原子性操作</p>
</blockquote>
<pre><code>AtomicInteger atomicInteger = new AtomicInteger(5);
atomicInteger.getAndIncrement();
</code></pre>
<!---->

<pre><code>ConcurrentHashMap&lt;String,String&gt; concurrentHashMap=new ConcurrentHashMap&lt;&gt;();
</code></pre>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>1.保证变量可见性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Whw extends Thread &#123;</span><br><span class="line">    private volatile boolean flag=false;</span><br><span class="line">    public boolean isFlag() &#123;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        flag=true;</span><br><span class="line">        System.out.println(&quot;flag=&quot;+flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Whw jerk = new Whw();</span><br><span class="line">        jerk.start();</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(jerk.isFlag())&#123;</span><br><span class="line">                System.out.println(&quot;小王有点东西&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.禁止指令重排序<br>编译器优化的重排序<br>指令级并行的重排序<br>内存系统的重排序<br>as-if-serial 内存屏障 happens-before</p>
<blockquote>
<p>创建对象<br>1.分配内存空间<br>2.调用构造函数 初始化成员变量值<br>3.将内存地址返回给引用<br>1 2 3-&gt;1 3 2</p>
</blockquote>
</blockquote>
<h2 id="Java设计模式"><a href="#Java设计模式" class="headerlink" title="Java设计模式"></a>Java设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote>
<p>三大特点<br>1.私有构造方法<br>2.静态的当前类自己的成员变量<br>3.提供public的获取实例的方法</p>
</blockquote>
<p>1.懒汉</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SingleTon &#123;</span><br><span class="line">    private static SingleTon instance;</span><br><span class="line">    private SingleTon()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static SingleTon getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new SingleTon();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SingleTon s1=SingleTon.getInstance();</span><br><span class="line">        SingleTon s2=SingleTon.getInstance();</span><br><span class="line">        System.out.println(s1==s2);//true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.饿汉<br>不存在线程安全问题</p>
<pre><code>public class SingleTon &#123;
    private static SingleTon instance=new SingleTon();
    private SingleTon()&#123;
    &#125;
    public static SingleTon getInstance()&#123;
        return instance;
    &#125;
&#125;
</code></pre>
<p>3.双重检查锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class SingleTon &#123;</span><br><span class="line">    //volatile负责禁止指令重排序</span><br><span class="line">    private volatile static SingleTon instance;</span><br><span class="line">    private SingleTon() &#123;&#125;</span><br><span class="line">    public  static SingleTon getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (SingleTon.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new SingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.静态内部类（仅知道）</p>
<blockquote>
<p>volatile和synchronized区别<br>volatile适用于以下场景：<br>某个属性被多个线程所共享<br>1.其中一个线程修改了改属性，其他线程可以立刻拿到修改后的值，类似于触发器，实现轻量级的数据同步<br>2.volatile的所有读写操作都是无锁的，不能替代synchronized。正因为无锁，可以节约获取锁盒释放锁的性能，但是不能保证原子性<br>3.volatile只能作用于变量，并且禁止指令重排序<br>4.volatile可以使long和double类型的赋值具有原子性<br>5.volatile在双重检查锁单例模式中，不仅保证了变量的可见性，也禁止了指令重排序，保证了单例的安全性</p>
</blockquote>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>本质是一种并发控制机制</p>
<blockquote>
<p>基本思想<br>不对数据写入操作加锁，而是在更新数据的时候检查自读取依赖数据是否被其他线程修改。如果数据没有被其他线程修改，则更新成功，否则充实或者进行其他处理</p>
</blockquote>
<blockquote>
<p>乐观锁的优点在于适合读多写少的场景，但是在并发场景下容易出现大量的重试操作，从而影响性能</p>
</blockquote>
<blockquote>
<p>乐观锁作用<br>1.减少锁的竞争<br>在并发场景中使用乐观锁，所有读写操作都需要加锁，而乐观锁通过假设数据修改很少发生，减少了锁的使用<br>2.提高系统的吞吐量<br>减少了锁的使用，多个线程可以同时进行读操作，只有在写操作的时候才会进行版本号的检查，从而提高系统的吞吐量<br>3.防止数据丢失<br>通过版本号的检查机制，可以检测到并发写操作</p>
</blockquote>
<pre><code>public class OptimisticLock &#123;
    //乐观锁的版本号
    private AtomicInteger version = new AtomicInteger();
    //提供获取版本号的方法
    public int getVersion() &#123;
        return version.get();
    &#125;
    //使用CAS操作来更新版本号
    public boolean compareAndSet(int expectVersion, int newVersion) &#123;
        return version.compareAndSet(expectVersion, newVersion);
    &#125;
&#125;
public class TestLock &#123;
    //创建一个乐观锁的对象
    private static OptimisticLock lock = new OptimisticLock();

    public static void main(String[] args) &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            new Thread(new Worker(),&quot;线程&quot;+i).start();
        &#125;
    &#125;
    static class Worker implements Runnable &#123;
        @Override
        public void run() &#123;
            int version;
            boolean success;
            do &#123;
                //获取当前版本号
                version = lock.getVersion();
                //使用sleep模拟业务操作
                try &#123;
                    System.out.println(Thread.currentThread().getName() + &quot;:正在执行业务操作...当前版本号为：&quot; + version);
                    Thread.sleep(100);
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
                //使用CAS操作更新版本号
                success=lock.compareAndSet(version, version+1);
                if(!success)&#123;
                    System.out.println(Thread.currentThread().getName()+&quot;:版本号冲突，正在重试...&quot;);
                &#125;
            &#125; while (!success);
            System.out.println(Thread.currentThread().getName()+&quot;版本号成功更新到了&quot;+(version+1));
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h2><blockquote>
<p>c&#x2F;s<br>client&#x2F;server<br>提供强大的功能支持<br>用户使用成本相对较高（客户端需要更新）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Server &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //创建服务器端 并且指定服务器端的对应窗口</span><br><span class="line">        ServerSocket serverSocket=new ServerSocket(8888);</span><br><span class="line">        System.out.println(&quot;正在8888端口进行监听&quot;);</span><br><span class="line">        Socket s=serverSocket.accept();</span><br><span class="line">        //通过客户端对象获取输入输出流</span><br><span class="line">        InputStream is=s.getInputStream();</span><br><span class="line">        DataInputStream dis=new DataInputStream(is);</span><br><span class="line">        OutputStream os=s.getOutputStream();</span><br><span class="line">        DataOutputStream dos=new DataOutputStream(os);</span><br><span class="line">        Scanner sc=new Scanner(System.in);</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            String msg= dis.readUTF();</span><br><span class="line">            System.out.println(&quot;客户端说：&quot;+msg);</span><br><span class="line">            String str=sc.nextLine();</span><br><span class="line">            dos.writeUTF(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //新建一个客户端socket对象 并且指定客户端锁连接的服务器端的ip地址和端口</span><br><span class="line">        //客户端默认由客户端所在设备随机分配一个端口</span><br><span class="line">        Socket s=new Socket(&quot;127.0.0.1&quot;,8888);</span><br><span class="line">        //获取输入输出流</span><br><span class="line">        OutputStream os=s.getOutputStream();</span><br><span class="line">        DataOutputStream dos=new DataOutputStream(os);</span><br><span class="line">        InputStream is=s.getInputStream();</span><br><span class="line">        DataInputStream dis=new DataInputStream(is);</span><br><span class="line">        Scanner sc=new Scanner(System.in);</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            String str=sc.nextLine();</span><br><span class="line">            dos.writeUTF(str);</span><br><span class="line">            String msg=dis.readUTF();</span><br><span class="line">            System.out.println(&quot;收到服务器消息：&quot;+msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>b&#x2F;s<br>browser&#x2F;server<br>满足常规的功能需求<br>使用成本低（有浏览器就行）<br>不能实现较为复杂的功能（例如大型游戏）</p>
</blockquote>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射提出了一种思想：万物都是对象<br>类可以是对象，方法、成员变量、方法参数、构造函数等等都可以是对象</p>
<blockquote>
<p>类对象 Class<br>每一个类所对应的类对象 全局唯一（在类加载的时候自动创建，但是只会创建一次）</p>
</blockquote>
<h3 id="类对象的三种获取方式"><a href="#类对象的三种获取方式" class="headerlink" title="类对象的三种获取方式"></a>类对象的三种获取方式</h3><p>1.通过class方式直接获取</p>
<pre><code>Class class1=Test.class;
</code></pre>
<p>2.通过Class.forName（）方法获取</p>
<pre><code>Class class2=Class.forName(&quot;com.iweb.test.test1.Test&quot;);
</code></pre>
<p>3.通过该类的对象获取</p>
<pre><code>Class class3=new Test().getClass();
</code></pre>
<p>不管通过哪种方式获取的类对象 都是同一个对象（每一个类的类对象全局只加载一次）</p>
<pre><code>System.out.println(class1==class2);
</code></pre>
<blockquote>
<p>反射可以在不使用new的情况下创建对象</p>
</blockquote>
<pre><code>public class Test &#123;
    public static void main(String[] args) throws Exception &#123;
        //传统new创建对象的方式
        Student s=new Student();
        //反射方式创建对象
        //1.获取学生类的反射对象
        Class sClass=Class.forName(&quot;com.iweb.test.test2.Test&quot;);
        //2.获取无参构造方法的反射对象
        Constructor&lt;Student&gt; c=sClass.getConstructor();
        //3.借助无参构造方法的反射对象进行对象的实例化
        Student s2=c.newInstance();
    &#125;
&#125;
</code></pre>
<blockquote>
<p>配置优于实现<br>约定优于配置</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//配置文件</span><br><span class="line">className=com.iweb.test.test3.Dog</span><br><span class="line">//代码</span><br><span class="line">public interface Animal &#123;</span><br><span class="line">    void eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Dog implements Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;狗吃骨头&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Person implements Animal&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;人吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class AnimalUtil &#123;</span><br><span class="line">    public static Animal getInstance() throws Exception &#123;</span><br><span class="line">        //获取配置文件的文件对象</span><br><span class="line">        File animalFile = new File(&quot;C:\\idea_workspace\\maven_base\\d1128_java14\\src\\main\\java\\com\\iweb\\test\\test3\\animal.properties&quot;);</span><br><span class="line">        //实例化Properties类对象 该类专门用于做配置文件的读取</span><br><span class="line">        Properties animalProperties = new Properties();</span><br><span class="line">        //让Properties类对象读取配置文件</span><br><span class="line">        animalProperties.load(new FileInputStream(animalFile));</span><br><span class="line">        //获取配置文件中的属性</span><br><span class="line">        String className=(String)animalProperties.get(&quot;className&quot;);</span><br><span class="line">        //获取反射对象</span><br><span class="line">        Class animalClass = Class.forName(className);</span><br><span class="line">        //获取该对象对应的构造函数的反射对象</span><br><span class="line">        Constructor&lt;Animal&gt; c = animalClass.getConstructor();</span><br><span class="line">        //返回Animal的子类对象</span><br><span class="line">        return c.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)throws Exception &#123;</span><br><span class="line">        Animal a=AnimalUtil.getInstance();</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>反射还可以用于方法调用</p>
</blockquote>
<pre><code>public class TJLUtil &#123;
    public void late()&#123;
        System.out.println(&quot;tjl迟到了，没有想好理由&quot;);
    &#125;
    public void late(String reason)&#123;
        System.out.println(&quot;tjl迟到了，理由是：&quot;+reason);
    &#125;
&#125;
public class Test &#123;
    public static void main(String[] args) throws Exception &#123;
        //获取工具类的反射对象
        Class tjlUtilClass=Class.forName(&quot;com.iweb.test.test4.TJLUtil&quot;);
        //获取工具类的构造函数的反射对象
        Constructor&lt;TJLUtil&gt; tjlUtilConstructor=tjlUtilClass.getConstructor();
        //通过反射实例化 得到一个工具类对象
        TJLUtil tjl=tjlUtilConstructor.newInstance();
        //获取工具类中的指定方法（无参）的反射对象
        Method lateMethod=tjlUtilClass.getMethod(&quot;late&quot;);
        //执行方法
        lateMethod.invoke(tjl);
        //获取工具类中的指定方法（有参）的反射对象
        //在获取有参数的方法的反射对象的时候 需要提供参数类型对应的反射对象
        Method lateMethodWithArg=tjlUtilClass.getMethod(&quot;late&quot;,String.class);
        //执行这个有参数的late方法
        lateMethodWithArg.invoke(tjl,&quot;请大家喝蜜雪冰城&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注释和代码结合的产物 标签</p>
<blockquote>
<p>妈妈的字条 冰箱上<br>to:小王<br>留言：冰箱里有饭菜，不要点外卖</p>
</blockquote>
<h3 id="系统注解"><a href="#系统注解" class="headerlink" title="系统注解"></a>系统注解</h3><p>@Override 重写方法</p>
<pre><code>public class Test &#123;
    @Override
    public String toString() &#123;
        return null;
    &#125;
&#125;
</code></pre>
<p>@Deprecated 弃用的方法</p>
<p>@SupperessWarnings 抑制警告</p>
<pre><code>public class Test &#123;
    @SuppressWarnings(&quot;all&quot;)
    public static void main(String[] args) &#123;
        int a=1;
    &#125;
&#125;
</code></pre>
<p>@FunctionakInterface 函数式接口<br>如果接口中有且只有一个抽象方法 那么这个接口就叫做函数式接口<br>（用于lamda匿名表达式和流式计算）<br>@Resource 等价于spring的@Autowired 用于对象的自动装配</p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>用来注解注解的注解</p>
<blockquote>
<p>ElementType.TYPE 表示当前注解可以作用于类上<br>ElementType.MYTHED 表示当前注解可以作用于方法上<br>ElementType.FIELD 表示当前注解可以作用于成员变量上<br>ElementType.PARAMETER 表示当前注解可以作用于形参上<br>ElementType.CONSTRUCTOR 表示当前注解可以作用于构造方法上<br>ElementType.LOCAL_VARIABLE 表示当前注解可以作用于局部变量上<br>ElementType.ANNOTATION_TYPE 表示当前注解可以作用于注解上<br>ElementType.PACKAGE 表示当前注解可以作用于包上</p>
</blockquote>
<p>@Target({METHOD,TYPE})<br>当前注解是一个运行时注解 直到代码运行之后 才会获得注解中的相关信息<br>RetentionPolicy.SOURCE<br>表示当前注解只保留在源文件中 编译成class之后自动消失<br>RetentionPolicy.CLASS<br>表示当前注解保留在class文件中 但是在代码运行的时候就会自动消失<br>RetentionPolicy.RUNTIME<br>表示当前注解保留在class文件中 并且在代码运行的时候也会保留 这种生命周期的设置方便我们通过反射获取注解的值</p>
<p>@Repeatable（jdk1.8新增）当没有该元注解修饰的时候 注解只能在同一个位置出现一次 当某个自定义注解有该元注解修饰的时候，可以在同一个位置出现多次</p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>每一个自定义注解需要通过元注解来定义注解的使用范围和生命周期</p>
<p>@Target({METHOD,TYPE})<br>表示当前注解可以用于类上或方法上</p>
<p>@Retention（RetentionPolicy.RUNTIME）<br>当前注解是一个运行时注解 直到代码运行之后，才会获得注解中的相关信息</p>
<p>@Inherited<br>当前定义的注解在使用的时候，可以被使用该注解的类的子类自动继承</p>
<p>@Documented<br>当前注解支持使用javadoc生成相关文档</p>
<p>@JDBCConfig</p>
<pre><code>public @interface JDBCConfig &#123;
    String ip();
    int port() default 3306;
    String database();
    String encoding();
    String username();
    String password();
&#125;
@JDBCConfig(ip=&quot;localhost&quot;,database = &quot;nuist&quot;,username = &quot;root&quot;,password = &quot;a12345&quot;,encoding = &quot;utf8&quot;)
public class DBUtil &#123;
    static &#123;
        try &#123;
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    public static Connection getConnection()throws Exception &#123;
        //先获取注解对象
        JDBCConfig config=DBUtil.class.getAnnotation(JDBCConfig.class);
        String ip=config.ip();
        int port=config.port();
        String database=config.database();
        String username=config.username();
        String password=config.password();
        String url=String.format(&quot;jdbc:mysql://%s:%d/%s?characterEncoding=%s&quot;,ip,port,database,config.encoding());
        return DriverManager.getConnection(url,username,password);
    &#125;
&#125;
public class Test &#123;
    public static void main(String[] args) throws Exception &#123;
        System.out.println(DBUtil.getConnection());
    &#125;
&#125;
</code></pre>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>限制参数类型</p>
<pre><code>public enum Season &#123;
    SPRING, SUMMER, AUTUMN, WINTER;
&#125;
public class Test &#123;
    public static void chooseSeason(Season season) &#123;
        switch (season) &#123;
            case SPRING:
                System.out.println(&quot;春天&quot;);
                break;
            case SUMMER:
                System.out.println(&quot;夏天&quot;);
                break;
            case AUTUMN:
                System.out.println(&quot;秋天&quot;);
                break;
            case WINTER:
                System.out.println(&quot;冬天&quot;);
                break;
            default:
                System.out.println(&quot;输入的季节名称有误&quot;);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        chooseSeason(Season.SPRING);
    &#125;
&#125;
</code></pre>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>本质是匿名方法 将方法作为参数进行传递的编程思想<br>java在运行时候 会将lambda匿名表达式还原匿名内部类<br>我们最终传递给方法的参数 本质还是StudnetChecker接口的实现类对象</p>
<blockquote>
<p>实现的接口只有一个抽象方法</p>
</blockquote>
<pre><code>public class Student &#123;
    private Integer age;
    private String name;
&#125;
@FunctionalInterface
public interface StudentChecker &#123;
    public boolean check(Student student);
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        Random r=new Random();
        List&lt;Student&gt; stus=new ArrayList&lt;Student&gt;();
        for(int i=0;i&lt;100;i++)&#123;
            stus.add(new Student(r.nextInt(100),&quot;student&quot;+i ));
        &#125;
        //使用匿名内部类方式实现StudentChecker接口进行实例化
/*        StudentChecker checker=new StudentChecker() &#123;
            @Override
            public boolean check(Student student) &#123;
                return student.getAge()&gt;=80;
            &#125;
        &#125;;
        filter(stus,checker);*/
        //lambda匿名表达式写法
        filter(stus,student -&gt; student.getAge()&lt;80);
    &#125;
    private static void filter(List&lt;Student&gt; stus,StudentChecker checker)&#123;
        for(Student stu:stus)&#123;
            if(checker.check(stu))&#123;
                System.out.print(stu+&quot;\t&quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<!---->

<pre><code>public class Student &#123;
    private Integer age;
    private String name;
&#125;
@FunctionalInterface
public interface StudentChecker &#123;
    public boolean check(Student student);
&#125;
public class Test1 &#123;
    public static void main(String[] args) &#123;
        Random r=new Random();
        List&lt;Student&gt; stus=new ArrayList&lt;Student&gt;();
        for(int i=0;i&lt;100;i++)&#123;
            stus.add(new Student(r.nextInt(100),&quot;student&quot;+i ));
        &#125;
        StudentChecker sc=new StudentChecker() &#123;
            @Override
            public boolean check(Student student) &#123;
                return student.getAge()&lt;80;
            &#125;
        &#125;;
        //1.使用匿名内部类过滤
        filter(stus,sc);
        //2.使用lambda表达式过滤
        filter(stus,student-&gt;student.getAge()&lt;80);
        //3.在lambda表达式中使用静态方法
        filter(stus,student-&gt;Test1.checkStudent(student));
        //4.直接引用静态方法
        filter(stus,Test1::checkStudent);
        //5.直接引用对象方法 这种方式要求先实例被引用方法的对象
        Test1 t=new Test1();
        filter(stus,t::ckStudent);
        //6.引用容器中对象的方法 用于进行结果的过滤
        filter(stus,student-&gt;student.matched());
        filter(stus,Student::matched);
        //7.通过六十计算的方式进行数据的筛选和操作
        //Stream是一系列的元素 类似于集合
        //管道指的是一系列的流式操作
        //管道分为3个部分
        //1.管道源 在当前demo中 指的是stus集合
        //2.中间操作 每一个中间操作（例如filter） 会返回一个Stream 如果你后续
        //还有其他中间操作 可以继续进行调用
        //3.结束操作 当结束操作执行之后 流相当于就被用光了 无法被操作
        //结束操作必然是流的最后一个操作 结束操作不会返回Stream 而是会返回int float String或者是Collection
        //或者是我们这里所写的forEach 什么都不返回 一般只在结束操作中进行遍历相关的操作
        //特别地 流式计算中涉及到的Stream 和我们前面学习的I/O流的Stream 没有任何关系
        stus.stream()
                .filter(s-&gt;s.getAge()&lt;80)
                .filter(s-&gt;s.getAge()&gt;60)
                .forEach(s-&gt;System.out.println(s+&quot;\t&quot;));
        //所有的Collection集合都支持直接获取管道源
        //数组是没有Stream方法 需要使用特殊方法转换
        
        //当管道源是集合的时候 直接遍历
        stus.stream().forEach(s -&gt; System.out.println(s));
        //当管道源是数组的时候 需要转换之后遍历
        Student[] ss = stus.toArray(new Student[stus.size()]);
        Arrays.stream(ss).forEach(s -&gt; System.out.println(s));
        //中间操作
        //filter 匹配
        //distinct 去重（equals方法结果判断是否相同）
        //sorted 自然排序
        //sorted(Comparator&lt;T&gt;) 按照指定的比较器进行排序
        //limit 截取（保留部分数据）
        //skip 忽略
        //转换为其他形式的流
        //mapToDouble 转换为double流
        //map 转换为任意类型的流
        stus.stream().filter(s-&gt;s.getAge()&lt;80).forEach(s-&gt;System.out.println(s));
        //利用distinct进行去重 重复判断的标准时equals方法比较的结果
        stus.stream().distinct().forEach(s-&gt;System.out.println(s));
        //也可以按照指定的方式进行排序 按照年龄排序
        //sorted中 如果不写lambda表达式 并且管道源中的数据所属的类实现了Comparable接口
        //则按照定义的规则进行排序
        //如果sorted方法中有lambda表达式 则相当于是用lambda写了一个临时的Comparator接口的实现类的重写方法
        stus.stream().
                sorted((s1,s2)-&gt;s1.getAge()&gt;=s2.getAge()?1:-1).
                forEach(s-&gt;System.out.println(s));
        //也可以保留集合的指定数据
        stus.stream().limit(3).forEach(s-&gt;System.out.println(s));
        //也可以忽略前3个
        stus.stream().skip(3).forEach(s-&gt;System.out.println(s));
        //中间操作可以有多个 每一层方法调用完之后都会返回Stream对象 所以可以连续调用 这种方法调用也叫做链式调用
        stus
                .stream()
                .sorted((s1,s2)-&gt;s1.getAge()&gt;= s2.getAge()?1:-1)
                .limit(10)
                .skip(5)
                .filter(s-&gt;s.getAge()&gt;=20)
                .forEach(s-&gt;System.out.println(s));
        //结束操作 当进行结束操作的时候 流就被用光了 无法继续操作 所以必须是流操作的最后一步
        //forEach是遍历每一个元素
        //toArray 转换成数组
        //min&lt;Comparator&lt;T&gt;&gt; 取最小元素
        //max&lt;Comparator&lt;T&gt;&gt; 取最大元素
        //count() 总数
        //findFirst 获取第一个元素
        //返回一个数组
        Object[] ss1=stus.stream().toArray();
        Student minAgeStudent=
                stus.stream()
                        .min((s1,s2)-&gt;s1.getAge()-s2.getAge())
                        .get();
        //返回年龄最高的学生
        Student maxAgeStudent=stus.stream()
                .max((s1,s2)-&gt;s1.getAge()- s2.getAge())
                .get();
        //也可以用于获取流中等数据的总数
        long count=stus.stream().filter(s-&gt;s.getAge()&gt;20).count();
        //获取流中数据的第一条数据
        Student firstStudent=
                stus.stream().findFirst().get();
    &#125;
    public boolean ckStudent(Student student)&#123;
        return student.getAge()&lt;80;
    &#125;
    public static Boolean checkStudent(Student s)&#123;
        return s.getAge()&lt;80;
    &#125;

    private static void filter(List&lt;Student&gt; stus,StudentChecker checker)&#123;
        for(Student stu:stus)&#123;
            if(checker.check(stu))&#123;
                System.out.print(stu+&quot;\t&quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="流式计算"><a href="#流式计算" class="headerlink" title="流式计算"></a>流式计算</h3><p>通过流式计算的方式进行数据的筛选和操作<br>Stream是一系列的元素 类似于集合<br>管道指的是一系列的流式操作</p>
<blockquote>
<p>管道分为3个部分<br>1.管道源 在当前demo中 指的是stus集合<br>2.中间操作 每一个中间操作（例如filter） 会返回一个Stream，如果你后续还有其他中间操作，可以继续进行调用<br>3.结束操作 当结束操作执行之后 流相当于就被用光了 无法被操作 结束操作必然是流的最后一个操作 结束操作不会返回Stream 而是会返回int float String或者是Collection<br>或者是我们这里所写的forEach 什么都不返回 一般只在结束操作中进行遍历相关的操作<br>特别地 流式计算中涉及到的Stream 和我们前面学习的I&#x2F;O流的Stream 没有任何关系</p>
</blockquote>
<pre><code>stus.stream()
        .filter(s-&gt;s.getAge()&lt;80)
        .filter(s-&gt;s.getAge()&gt;60)
        .forEach(s-&gt;System.out.println(s+&quot;\t&quot;));
</code></pre>
<p>所有的Collection集合都支持直接获取管道源<br>数组是没有Stream方法 需要使用特殊方法转换*&#x2F;<br>当管道源是集合的时候 直接遍历</p>
<pre><code>stus.stream().forEach(s -&gt; System.out.println(s));
</code></pre>
<p>当管道源是数组的时候 需要转换之后遍历</p>
<pre><code>Student[] ss = stus.toArray(new Student[stus.size()]);
Arrays.stream(ss).forEach(s -&gt; System.out.println(s));
</code></pre>
<p>中间操作<br>filter 匹配<br>distinct 去重（equals方法结果判断是否相同）<br>sorted 自然排序<br>sorted(Comparator&lt;T&gt;) 按照指定的比较器进行排序<br>limit 截取（保留部分数据）<br>skip 忽略<br>转换为其他形式的流<br>mapToDouble 转换为double流<br>map 转换为任意类型的流</p>
<pre><code>stus.stream().filter(s-&gt;s.getAge()&lt;80).forEach(s-&gt;System.out.println(s));
</code></pre>
<p>利用distinct进行去重 重复判断的标准时equals方法比较的结果</p>
<pre><code>stus.stream().distinct().forEach(s-&gt;System.out.println(s));
</code></pre>
<p>也可以按照指定的方式进行排序 按照年龄排序<br>sorted中 如果不写lambda表达式 并且管道源中的数据所属的类实现了Comparable接口,则按照定义的规则进行排序<br>如果sorted方法中有lambda表达式 则相当于是用lambda写了一个临时的Comparator接口的实现类的重写方法</p>
<pre><code>stus.stream().
        sorted((s1,s2)-&gt;s1.getAge()&gt;=s2.getAge()?1:-1).
        forEach(s-&gt;System.out.println(s));
</code></pre>
<p>也可以保留集合的指定数据</p>
<pre><code>stus.stream().limit(3).forEach(s-&gt;System.out.println(s));
</code></pre>
<p>也可以忽略前3个</p>
<pre><code>stus.stream().skip(3).forEach(s-&gt;System.out.println(s));
</code></pre>
<p>中间操作可以有多个 每一层方法调用完之后都会返回Stream对象 所以可以连续调用 这种方法调用也叫做链式调用</p>
<pre><code>stus
        .stream()
        .sorted((s1,s2)-&gt;s1.getAge()&gt;= s2.getAge()?1:-1)
        .limit(10)
        .skip(5)
        .filter(s-&gt;s.getAge()&gt;=20)
        .forEach(s-&gt;System.out.println(s));
</code></pre>
<p>结束操作 当进行结束操作的时候 流就被用光了 无法继续操作 所以必须是流操作的最后一步</p>
<blockquote>
<p>forEach是遍历每一个元素<br>toArray 转换成数组<br>min&lt;Comparator&lt;T&gt;&gt; 取最小元素<br>max&lt;Comparator&lt;T&gt;&gt; 取最大元素<br>count() 总数<br>findFirst 获取第一个元素</p>
</blockquote>
<p>返回一个数组</p>
<pre><code>Object[] ss1=stus.stream().toArray();
Student minAgeStudent=
        stus.stream()
                .min((s1,s2)-&gt;s1.getAge()-s2.getAge())
                .get();
</code></pre>
<p>返回年龄最高的学生</p>
<pre><code>Student maxAgeStudent=stus.stream()
        .max((s1,s2)-&gt;s1.getAge()- s2.getAge())
        .get();
</code></pre>
<p>也可以用于获取流中等数据的总数</p>
<pre><code>long count=stus.stream().filter(s-&gt;s.getAge()&gt;20).count();
</code></pre>
<p>获取流中数据的第一条数据</p>
<pre><code>Student firstStudent=
        stus.stream().findFirst().get();
</code></pre>
<script src="https://utteranc.es/client.js"
        repo="Nuist666/blog_comment"
        issue-term="Java笔记"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2024/04/14/%E5%8D%8E%E4%B8%BA%E4%BA%91/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">华为云——基于Hexo快速搭建博客</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2024 Nuist666
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>